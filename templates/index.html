<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Network Discovery Tool</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --accent-primary: #3b82f6;
      --accent-secondary: #8b5cf6;
      --accent-success: #10b981;
      --border-color: #334155;
      --shadow: rgba(0, 0, 0, 0.3);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow: hidden;
    }

    /* Header */
    header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 0.75rem 2rem 0 2rem;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      box-shadow: 0 2px 8px var(--shadow);
      z-index: 100;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .controls {
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .control-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    select {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 150px;
    }

    select:hover {
      border-color: var(--accent-primary);
      background: var(--bg-secondary);
    }

    select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Main Layout */
    .container {
      display: flex;
      height: calc(100vh - 73px);
    }

    /* Sidebar */
    .sidebar {
      width: 360px;
      background: rgba(30, 41, 59, 0.85);
      backdrop-filter: blur(12px);
      border-right: 1px solid rgba(51, 65, 85, 0.6);
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
    }

    .card {
      background: rgba(51, 65, 85, 0.5);
      border-radius: 0.75rem;
      padding: 1rem;
      border: 1px solid rgba(51, 65, 85, 0.6);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .card-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
    }

    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    input[type="text"] {
      flex: 1;
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(51, 65, 85, 0.6);
      color: var(--text-primary);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    button {
      background: var(--accent-primary);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    button:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
    }

    button.secondary:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-primary);
      box-shadow: none;
    }

    .list-box {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      margin-bottom: 0.375rem;
    }

    .list-item {
      background: rgba(51, 65, 85, 0.5);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid rgba(51, 65, 85, 0.6);
      font-family: 'Monaco', 'Courier New', monospace;
      position: relative;
      padding-right: 4rem;
    }

    .endpoint-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: calc(100% - 3rem);
      display: inline-block;
    }

    .endpoint-bytes {
      position: absolute;
      right: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.625rem;
      color: var(--text-secondary);
      background: rgba(15, 23, 42, 0.5);
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      white-space: nowrap;
    }

    .list-item:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .list-item:active {
      transform: translateY(0);
    }

    .list-item.selected {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }

    .section {
      margin-bottom: 0.75rem;
    }

    .section:last-child {
      margin-bottom: 0;
    }

    /* Graph Container */
    #graph-container {
      flex: 1;
      position: relative;
      background: var(--bg-primary);
    }

    #cy {
      width: 100%;
      height: 100%;
      padding-right: 320px;
    }

    /* Zoom Controls */
    .zoom-controls {
      position: absolute;
      bottom: 2.5rem;
      right: 385px;
      display: flex;
      flex-direction: row;
      gap: 0.25rem;
      z-index: 10;
    }

    .zoom-btn {
      width: 32px;
      height: 32px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      color: var(--text-primary);
      font-size: 1.25rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .zoom-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-primary);
    }

    .zoom-btn:active {
      transform: scale(0.95);
    }

    /* Stats Badge */
    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.375rem;
      margin-top: 0.5rem;
    }

    .stat-badge {
      background: rgba(15, 23, 42, 0.5);
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.6875rem;
      color: var(--text-secondary);
    }

    .stat-badge.stat-link {
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .stat-badge.stat-link:hover {
      background: rgba(139, 92, 246, 0.3);
      color: var(--text-primary);
    }

    .stat-number {
      color: var(--accent-primary);
      font-weight: 600;
    }

    /* Device Type Dropdown */
    .device-type-selector {
      position: relative;
      display: inline-block;
    }

    .device-type-btn {
      background: rgba(59, 130, 246, 0.2);
      border: 1px solid rgba(59, 130, 246, 0.4);
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
    }

    .device-type-btn:hover {
      background: rgba(59, 130, 246, 0.3);
      border-color: rgba(59, 130, 246, 0.6);
    }

    .device-type-btn .dropdown-arrow {
      font-size: 0.5rem;
      opacity: 0.7;
    }

    .device-type-btn.manual-override {
      background: rgba(139, 92, 246, 0.2);
      border-color: rgba(139, 92, 246, 0.4);
    }

    .device-type-btn.manual-override:hover {
      background: rgba(139, 92, 246, 0.3);
      border-color: rgba(139, 92, 246, 0.6);
    }

    .device-type-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 0.25rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      box-shadow: 0 4px 12px var(--shadow);
      z-index: 1000;
      min-width: 160px;
      display: none;
      overflow: hidden;
    }

    .device-type-dropdown.open {
      display: block;
    }

    .device-type-option {
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .device-type-option:hover {
      background: rgba(59, 130, 246, 0.1);
      color: var(--text-primary);
    }

    .device-type-option.selected {
      background: rgba(59, 130, 246, 0.2);
      color: var(--text-primary);
    }

    .device-type-option.auto-option {
      border-bottom: 1px solid var(--border-color);
      color: var(--accent-primary);
    }

    .pulse {
      width: 8px;
      height: 8px;
      background: var(--accent-success);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .pulse.stopped {
      background: #ef4444;
      animation: none;
      opacity: 1;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .stop-refresh-btn {
      padding: 0.25rem 0.5rem;
      background: transparent;
      border: none;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 1.25rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      transition: all 0.2s ease;
    }

    .stop-refresh-btn:hover {
      transform: scale(1.05);
    }

    .stop-refresh-btn:active {
      transform: scale(0.95);
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0.375rem;
      padding-bottom: 0;
      margin-bottom: 0;
      margin-top: 0.875rem;
      margin-left: 1.5rem;
    }

    .tab-btn {
      padding: 0.375rem 0.625rem;
      background: rgba(51, 65, 85, 0.4);
      border: 1px solid var(--border-color);
      border-radius: 0.25rem 0.25rem 0 0;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-secondary);
      font-size: 0.65rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: -1px;
    }

    .tab-btn:hover {
      background: rgba(139, 92, 246, 0.2);
      border-color: rgba(139, 92, 246, 0.4);
      color: var(--text-primary);
    }

    .tab-btn.active {
      background: var(--bg-primary);
      border-color: var(--border-color);
      border-bottom-color: var(--bg-primary);
      color: var(--text-primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* DNS Table */
    .dns-table-container {
      padding: 1rem;
      overflow: auto;
      height: calc(100vh - 73px);
    }

    .dns-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .dns-table th,
    .dns-table td {
      padding: 0.5rem 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
    }

    .dns-table th {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-weight: 600;
      position: sticky;
      top: 0;
    }

    .dns-table tr:hover {
      background: rgba(139, 92, 246, 0.1);
    }

    .dns-table td {
      color: var(--text-primary);
      font-family: 'Monaco', 'Courier New', monospace;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--border-color);
    }

    /* Empty state */
    .empty-state {
      color: var(--text-secondary);
      font-size: 0.75rem;
      font-style: italic;
      padding: 0.375rem 0.5rem;
    }

    /* Range slider styling */
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      border: 2px solid rgba(15, 23, 42, 0.8);
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      border: 2px solid rgba(15, 23, 42, 0.8);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #10b981;
    }

    input[type="range"]::-moz-range-thumb:hover {
      background: #10b981;
    }

    /* Protocols Overlay */
    .protocols-overlay {
      position: absolute;
      top: 1rem;
      right: 1rem;
      width: 340px;
      height: calc(100vh - 120px);
      background: rgba(30, 41, 59, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(51, 65, 85, 0.6);
      border-radius: 0.75rem;
      padding: 1rem;
      z-index: 10;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      overflow-y: auto;
    }

    .overlay-header {
      font-size: 0.875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      padding-bottom: 0.5rem;
      margin-bottom: 0.75rem;
      border-bottom: 1px solid rgba(51, 65, 85, 0.6);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .overlay-header:not(:first-child) {
      margin-top: 0.75rem;
    }

    .clear-filter-btn, .clear-port-filter-btn {
      background: var(--accent-secondary);
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.625rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .clear-filter-btn:hover, .clear-port-filter-btn:hover {
      background: #7c3aed;
      transform: translateY(-1px);
    }

    .overlay-content {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .protocol-badge {
      background: rgba(51, 65, 85, 0.5);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid rgba(51, 65, 85, 0.6);
      white-space: nowrap;
    }

    .protocol-badge:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .protocol-badge:active {
      transform: translateY(0);
    }

    .protocol-badge.selected {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }

    .protocol-badge.dimmed {
      opacity: 0.4;
    }

    .overlay-hostnames {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      margin-bottom: 0.75rem;
    }

    .hostname-item {
      background: transparent;
      color: var(--text-primary);
      padding: 0.25rem 0 0.25rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 400;
      cursor: default;
      font-family: 'Monaco', 'Courier New', monospace;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <header>
    <div style="display: flex; flex-direction: column; justify-content: space-between; height: 100%;">
      <div class="logo">‚ö° Rust Network Discovery Tool</div>
      <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('network')">Network</button>
        <button class="tab-btn" onclick="switchTab('dns')">mDNS Entries</button>
      </div>
    </div>
    <div class="controls">
      <div class="control-group" id="time-range-controls">
        <label class="control-label">Time Range</label>
        <select id="scanInterval" onchange="selectScanInterval(this.value)">
          <option value="5" {% if scan_interval == 5 %}selected{% endif %}>5 Minutes</option>
          <option value="15" {% if scan_interval == 15 %}selected{% endif %}>15 Minutes</option>
          <option value="30" {% if scan_interval == 30 %}selected{% endif %}>30 Minutes</option>
          <option value="60" {% if scan_interval == 60 %}selected{% endif %}>1 Hour</option>
          <option value="240" {% if scan_interval == 240 %}selected{% endif %}>4 Hours</option>
          <option value="1440" {% if scan_interval == 1440 %}selected{% endif %}>1 Day</option>
        </select>
      </div>
      <div class="control-group" id="auto-refresh-controls">
        <label class="control-label">Auto-Refresh</label>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <select id="refreshInterval" onchange="updateRefreshInterval(this.value)">
            <option value="0">Off</option>
            <option value="3">3 seconds</option>
            <option value="5" selected>5 seconds</option>
            <option value="10">10 seconds</option>
            <option value="30">30 seconds</option>
            <option value="60">1 minute</option>
          </select>
          <button onclick="manualRefresh()" class="stop-refresh-btn" title="Refresh now">
            üîÑ
          </button>
          <button id="refreshToggleBtn" onclick="toggleRefresh()" class="stop-refresh-btn" style="margin-right: 0.5rem;" title="Stop auto-refresh">
            ‚èπÔ∏è
          </button>
          <div class="pulse"></div>
        </div>
      </div>
    </div>
  </header>

  <!-- Network Tab Content -->
  <div id="network-tab" class="tab-content active">
  <div class="container">
    <aside class="sidebar">
      <div class="card">
        <div class="card-title" style="margin-bottom: 0; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(51, 65, 85, 0.6);">Endpoints</div>

        <!-- Filter Controls -->
        <div style="display: flex; justify-content: flex-start; gap: 0.5rem; margin-top: 0.75rem; margin-bottom: 0.375rem;">
          <button onclick="selectAllFilters()" style="font-size: 0.7rem; padding: 0.125rem 0.375rem; background: rgba(59, 130, 246, 0.2); border: 1px solid rgba(59, 130, 246, 0.4); color: #60a5fa; border-radius: 0.25rem; cursor: pointer; font-weight: 500;">All</button>
          <button onclick="selectNoneFilters()" style="font-size: 0.7rem; padding: 0.125rem 0.375rem; background: rgba(100, 116, 139, 0.2); border: 1px solid rgba(100, 116, 139, 0.4); color: #94a3b8; border-radius: 0.25rem; cursor: pointer; font-weight: 500;">None</button>
        </div>

        <!-- Filters -->
        <div style="display: flex; flex-direction: column; gap: 0.375rem; margin-bottom: 0.5rem;">
          <div style="display: flex; gap: 0.375rem; flex-wrap: nowrap;">
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(45, 27, 78, 0.5); border-radius: 0.375rem; border: 1px solid #8b5cf6; white-space: nowrap;">
              <input type="checkbox" id="filterLocal" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üíª Local</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(66, 32, 6, 0.5); border-radius: 0.375rem; border: 1px solid #f59e0b; white-space: nowrap;">
              <input type="checkbox" id="filterGateway" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üåê Gateway</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(8, 51, 68, 0.5); border-radius: 0.375rem; border: 1px solid #06b6d4; white-space: nowrap;">
              <input type="checkbox" id="filterInternet" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üåç Internet</span>
            </label>
          </div>
          <div style="display: flex; gap: 0.375rem; flex-wrap: wrap;">
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(30, 58, 40, 0.5); border-radius: 0.375rem; border: 1px solid #10b981; white-space: nowrap;">
              <input type="checkbox" id="filterPrinter" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üñ®Ô∏è Printer</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(60, 31, 95, 0.5); border-radius: 0.375rem; border: 1px solid #c084fc; white-space: nowrap;">
              <input type="checkbox" id="filterTv" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üì∫ TV</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(92, 28, 46, 0.5); border-radius: 0.375rem; border: 1px solid #f43f5e; white-space: nowrap;">
              <input type="checkbox" id="filterGaming" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üéÆ Gaming</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(8, 51, 51, 0.5); border-radius: 0.375rem; border: 1px solid #14b8a6; white-space: nowrap;">
              <input type="checkbox" id="filterPhone" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üì± Phone</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(30, 41, 59, 0.5); border-radius: 0.375rem; border: 1px solid #94a3b8; white-space: nowrap;">
              <input type="checkbox" id="filterVirtualization" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üñ• VM</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(49, 46, 129, 0.5); border-radius: 0.375rem; border: 1px solid #818cf8; white-space: nowrap;">
              <input type="checkbox" id="filterSoundbar" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üîä Soundbar</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(66, 32, 6, 0.5); border-radius: 0.375rem; border: 1px solid #fb923c; white-space: nowrap;">
              <input type="checkbox" id="filterAppliance" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>üè† Appliance</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; cursor: pointer; padding: 0.25rem 0.375rem; background: rgba(55, 65, 81, 0.5); border-radius: 0.375rem; border: 1px solid #9ca3af; white-space: nowrap;">
              <input type="checkbox" id="filterOther" checked onchange="applyFilters()" style="cursor: pointer;">
              <span>‚ùì Other</span>
            </label>
          </div>
        </div>

        <!-- Endpoint Limit Slider -->
        <div style="margin-bottom: 0.75rem;">
          <label style="display: flex; justify-content: space-between; align-items: center; font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.375rem;">
            <span>Show endpoints:</span>
            <span id="endpointLimitValue" style="color: var(--text-primary); font-weight: 500;">20</span>
          </label>
          <input type="range" id="endpointLimitSlider" min="10" max="100" value="20" step="10"
                 oninput="updateEndpointLimit(this.value)"
                 style="width: 100%; cursor: pointer; height: 4px; background: rgba(51, 65, 85, 0.6); border-radius: 2px; appearance: none; outline: none;">
        </div>

        <input type="text" id="endpointSearchInput" placeholder="Search endpoints..."
               oninput="debouncedEndpointSearch(this.value)"
               autofocus
               style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem; margin-bottom: 0.75rem;">
        <div class="list-box" id="endpoints-container">
          {% for node in dropdown_endpoints %}
          <div class="list-item {% if node == selected_node %}selected{% endif %}"
               onclick="selectNode('{{ node | safe }}')"
               data-endpoint="{{ node | safe }}"
               data-endpoint-type="{% if node == hostname %}local{% elif endpoint_types[node] == "gateway" %}gateway{% elif endpoint_types[node] == "internet" %}internet{% elif endpoint_types[node] == "printer" %}printer{% elif endpoint_types[node] == "tv" %}tv{% elif endpoint_types[node] == "gaming" %}gaming{% elif endpoint_types[node] == "phone" %}phone{% elif endpoint_types[node] == "virtualization" %}virtualization{% elif endpoint_types[node] == "soundbar" %}soundbar{% elif endpoint_types[node] == "appliance" %}appliance{% elif endpoint_types[node] %}local{% else %}other{% endif %}"
               data-endpoint-ips="{% if endpoint_ips_macs[node] %}{{ endpoint_ips_macs[node].0 | join(sep=",") }}{% endif %}"
               data-endpoint-macs="{% if endpoint_ips_macs[node] %}{{ endpoint_ips_macs[node].1 | join(sep=",") }}{% endif %}"
               data-endpoint-bytes="{{ endpoint_bytes[node] | default(value=0) }}">
            <span class="endpoint-name">{% if node == hostname %}üñ•Ô∏è{% elif endpoint_types[node] == "gateway" %}üåê{% elif endpoint_types[node] == "internet" %}üåç{% elif endpoint_types[node] == "printer" %}üñ®Ô∏è{% elif endpoint_types[node] == "tv" %}üì∫{% elif endpoint_types[node] == "gaming" %}üéÆ{% elif endpoint_types[node] == "phone" %}üì±{% elif endpoint_types[node] == "virtualization" %}üñ•{% elif endpoint_types[node] == "soundbar" %}üîä{% elif endpoint_types[node] == "appliance" %}üè†{% elif endpoint_types[node] %}üíª{% else %}‚ùì{% endif %} {{ node | safe }}</span>
            {% if endpoint_bytes[node] and endpoint_bytes[node] > 0 %}<span class="endpoint-bytes">{{ endpoint_bytes[node] }}</span>{% endif %}
          </div>
          {% endfor %}
        </div>
      </div>
    </aside>

    <main id="graph-container">
      <div id="cy"></div>

      <!-- Zoom Controls -->
      <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()" title="Zoom in">+</button>
        <button class="zoom-btn" onclick="zoomOut()" title="Zoom out">‚àí</button>
        <button class="zoom-btn" onclick="fitGraph()" title="Fit to view">‚ä°</button>
      </div>

      <!-- No Communications Message -->
      <div id="no-communications-msg" style="display: none; position: absolute; top: 50%; left: calc(50% - 160px); transform: translate(-50%, -50%); text-align: center; color: var(--text-secondary); pointer-events: none;">
        <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;">üì°</div>
        <div style="font-size: 1.25rem; font-weight: 500; margin-bottom: 0.5rem;">No Communications Found</div>
        <div style="font-size: 0.875rem; opacity: 0.7;">No network activity detected for this endpoint in the selected time range</div>
      </div>

      <!-- Protocols Overlay -->
      <div class="protocols-overlay">
        <!-- Endpoint Details -->
        <div class="overlay-header">
          Endpoint Details
        </div>
        <div style="margin-bottom: 0.75rem;">
          <!-- Endpoint Name -->
          <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem; word-break: break-all;">
            {{ endpoint }}
          </div>
          <!-- Device Type Dropdown -->
          <div style="margin-bottom: 0.75rem;">
            <div class="device-type-selector">
              <button class="device-type-btn {% if endpoint in manual_overrides %}manual-override{% endif %}" onclick="toggleDeviceTypeDropdown(event)" id="device-type-btn">
                <span>Type:</span>
                <span id="current-device-type">
                  {% if endpoint_types[endpoint] == "gateway" %}üåê Gateway
                  {% elif endpoint_types[endpoint] == "internet" %}üåç Internet
                  {% elif endpoint_types[endpoint] == "printer" %}üñ®Ô∏è Printer
                  {% elif endpoint_types[endpoint] == "tv" %}üì∫ TV
                  {% elif endpoint_types[endpoint] == "gaming" %}üéÆ Gaming
                  {% elif endpoint_types[endpoint] == "phone" %}üì± Phone
                  {% elif endpoint_types[endpoint] == "virtualization" %}üñ• VM
                  {% elif endpoint_types[endpoint] == "soundbar" %}üîä Soundbar
                  {% elif endpoint_types[endpoint] == "appliance" %}üè† Appliance
                  {% elif endpoint_types[endpoint] == "local" %}üñ•Ô∏è Local
                  {% elif endpoint_types[endpoint] %}üíª {{ endpoint_types[endpoint] }}
                  {% else %}‚ùì Other
                  {% endif %}
                </span>
                <span class="dropdown-arrow">‚ñº</span>
              </button>
              <div class="device-type-dropdown" id="device-type-dropdown">
                <div class="device-type-option auto-option" onclick="reclassifyEndpoint('auto')">üîÑ Auto (detect automatically)</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'local' %}selected{% endif %}" onclick="reclassifyEndpoint('local')">üñ•Ô∏è Local</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'printer' %}selected{% endif %}" onclick="reclassifyEndpoint('printer')">üñ®Ô∏è Printer</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'tv' %}selected{% endif %}" onclick="reclassifyEndpoint('tv')">üì∫ TV</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'gaming' %}selected{% endif %}" onclick="reclassifyEndpoint('gaming')">üéÆ Gaming</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'phone' %}selected{% endif %}" onclick="reclassifyEndpoint('phone')">üì± Phone</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'virtualization' %}selected{% endif %}" onclick="reclassifyEndpoint('virtualization')">üñ• VM</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'soundbar' %}selected{% endif %}" onclick="reclassifyEndpoint('soundbar')">üîä Soundbar</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'appliance' %}selected{% endif %}" onclick="reclassifyEndpoint('appliance')">üè† Appliance</div>
                <div class="device-type-option {% if endpoint_types[endpoint] == 'other' %}selected{% endif %}" onclick="reclassifyEndpoint('other')">‚ùì Other</div>
              </div>
            </div>
            {% if endpoint in manual_overrides %}<span style="font-size: 0.625rem; color: var(--accent-secondary); margin-left: 0.5rem;">(manually set)</span>{% endif %}
          </div>
          <div class="stats">
            <div class="stat-badge stat-link" onclick="scrollToSection('ips-section')">IPs: <span class="stat-number">{{ ips|length }}</span></div>
            <div class="stat-badge stat-link" onclick="scrollToSection('macs-section')">MACs: <span class="stat-number">{{ macs|length }}</span></div>
            <div class="stat-badge stat-link" onclick="scrollToSection('hostnames-section')">Hosts: <span class="stat-number">{{ hostnames|length }}</span></div>
            <div class="stat-badge stat-link" onclick="scrollToSection('ports-section')">Ports: <span class="stat-number">{{ ports|length }}</span></div>
            <div class="stat-badge stat-link" onclick="scrollToSection('protocols-section')">Protocols: <span class="stat-number">{{ protocols|length }}</span></div>
          </div>
          <div class="stats" style="margin-top: 0.5rem;">
            <div class="stat-badge">‚¨áÔ∏è In: <span class="stat-number" id="bytes-in">{{ bytes_in }}</span></div>
            <div class="stat-badge">‚¨ÜÔ∏è Out: <span class="stat-number" id="bytes-out">{{ bytes_out }}</span></div>
          </div>
        </div>

        <div class="overlay-header" id="protocols-section">
          Protocols
          <button class="clear-filter-btn" onclick="clearProtocolFilter()" style="display: none;">Clear Filter</button>
        </div>
        <div class="overlay-content" id="protocols-container">
          <!-- Protocols will be dynamically generated from graph data -->
        </div>

        <!-- Ports -->
        <div class="overlay-header" id="ports-section">
          Ports
          <button class="clear-port-filter-btn" onclick="clearPortFilter()" style="display: none;">Clear</button>
        </div>
        <div class="overlay-content" id="ports-container">
          {% if ports %}
            {% for port in ports %}
            <div class="protocol-badge" data-port="{{ port | safe }}" onclick="filterByPort('{{ port | safe }}', this)">{{ port | safe }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No ports</div>
          {% endif %}
        </div>

        <div class="overlay-header" id="hostnames-section">
          Hostnames
        </div>
        <div style="margin-bottom: 0.75rem;">
          <input type="text" id="hostnamesListSearch" placeholder="Filter hostnames..."
                 oninput="filterHostnamesList(this.value)"
                 style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
        </div>
        <div class="overlay-hostnames" id="hostnames-container">
          {% if hostnames %}
            {% for hostname in hostnames %}
            <div class="hostname-item">{{ hostname | safe }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No hostnames</div>
          {% endif %}
        </div>

        <!-- IP Addresses -->
        <div class="overlay-header" id="ips-section">
          IP Addresses
        </div>
        <div style="margin-bottom: 0.75rem;">
          <input type="text" id="ipsListSearch" placeholder="Filter IPs..."
                 oninput="filterIpsList(this.value)"
                 style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
        </div>
        <div class="overlay-hostnames" id="ips-container">
          {% if ips %}
            {% for ip in ips %}
            <div class="hostname-item">{{ ip | safe }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No IP addresses</div>
          {% endif %}
        </div>

        <!-- MAC Addresses -->
        <div class="overlay-header" id="macs-section">
          MAC Addresses
        </div>
        <div style="margin-bottom: 0.75rem;">
          <input type="text" id="macsListSearch" placeholder="Filter MACs..."
                 oninput="filterMacsList(this.value)"
                 style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
        </div>
        <div class="overlay-hostnames" id="macs-container">
          {% if macs %}
            {% for mac in macs %}
            <div class="hostname-item">{{ mac | safe }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No MAC addresses</div>
          {% endif %}
        </div>
      </div>
    </main>
  </div>
  </div><!-- End Network Tab -->

  <!-- DNS Tab Content -->
  <div id="dns-tab" class="tab-content">
    <div class="dns-table-container">
      <h2 style="color: var(--text-primary); margin-bottom: 1rem; font-size: 1.25rem;">mDNS Discovery Entries</h2>
      <table class="dns-table">
        <thead>
          <tr>
            <th>Timestamp</th>
            <th>IP Address</th>
            <th>Hostname</th>
            <th>Services</th>
          </tr>
        </thead>
        <tbody>
          {% for entry in dns_entries %}
          <tr>
            <td>{{ entry.timestamp }}</td>
            <td>{{ entry.ip }}</td>
            <td>{{ entry.hostname }}</td>
            <td>{{ entry.services }}</td>
          </tr>
          {% endfor %}
          {% if dns_entries | length == 0 %}
          <tr>
            <td colspan="4" style="text-align: center; color: var(--text-secondary); padding: 2rem;">No mDNS entries discovered yet</td>
          </tr>
          {% endif %}
        </tbody>
      </table>
    </div>
  </div><!-- End DNS Tab -->

  <script>
    // Track active tab
    let activeTab = 'network';

    // Tab switching function
    function switchTab(tabName) {
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      // Deactivate all tab buttons
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      // Show selected tab content
      document.getElementById(tabName + '-tab').classList.add('active');
      // Activate clicked button
      event.target.classList.add('active');

      // Update active tab
      activeTab = tabName;

      // If switching to DNS tab, do an immediate refresh of DNS entries
      if (tabName === 'dns') {
        refreshDnsEntries();
      }
    }

    // Fetch and update DNS entries table
    async function refreshDnsEntries() {
      try {
        const response = await fetch('/api/dns-entries');
        const entries = await response.json();

        const tbody = document.querySelector('.dns-table tbody');
        if (!tbody) return;

        // Use DocumentFragment for batched DOM updates (avoids multiple reflows)
        const fragment = document.createDocumentFragment();

        // Build all rows in the fragment first
        if (entries.length === 0) {
          const row = document.createElement('tr');
          row.innerHTML = '<td colspan="4" style="text-align: center; color: var(--text-secondary);">No mDNS entries discovered yet</td>';
          fragment.appendChild(row);
        } else {
          entries.forEach(entry => {
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${escapeHtml(entry.timestamp)}</td>
              <td>${escapeHtml(entry.ip)}</td>
              <td>${escapeHtml(entry.hostname)}</td>
              <td>${escapeHtml(entry.services)}</td>
            `;
            fragment.appendChild(row);
          });
        }

        // Single DOM operation: clear and append all at once
        tbody.innerHTML = '';
        tbody.appendChild(fragment);
      } catch (error) {
        // Silently fail - DNS refresh is non-critical
      }
    }

    // Helper to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Debounce utility for performance optimization
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Debounced endpoint search (waits 150ms after user stops typing)
    const debouncedEndpointSearch = debounce((value) => {
      filterEndpointsList(value, false, true); // Fast version that updates graph
    }, 150);

    // Debounced graph update (called after search completes)
    const debouncedGraphUpdate = debounce(() => {
      applyFilters(true);
    }, 150);

    // Navigation functions
    function selectNode(nodeId) {
      // Clear search input
      const searchInput = document.getElementById('endpointSearchInput');
      if (searchInput) {
        searchInput.value = '';
      }

      const url = new URL(window.location.href);
      url.searchParams.set('node', nodeId);
      url.searchParams.delete('filter_endpoints'); // Clear search from URL
      window.location.href = url.toString();
    }

    // Filter endpoints list in sidebar
    function filterEndpointsList(searchTerm, skipUrlUpdate = false, updateGraph = false) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const endpointItems = document.querySelectorAll('#endpoints-container .list-item');

      // Save to URL parameters
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        if (normalizedSearch) {
          url.searchParams.set('filter_endpoints', searchTerm);
        } else {
          url.searchParams.delete('filter_endpoints');
        }
        window.history.replaceState({}, '', url);
      }

      // Get current filter states
      const showLocal = document.getElementById('filterLocal').checked;
      const showGateway = document.getElementById('filterGateway').checked;
      const showInternet = document.getElementById('filterInternet').checked;
      const showPrinter = document.getElementById('filterPrinter').checked;
      const showTv = document.getElementById('filterTv').checked;
      const showGaming = document.getElementById('filterGaming').checked;
      const showPhone = document.getElementById('filterPhone').checked;
      const showVirtualization = document.getElementById('filterVirtualization').checked;
      const showSoundbar = document.getElementById('filterSoundbar').checked;
      const showAppliance = document.getElementById('filterAppliance').checked;
      const showOther = document.getElementById('filterOther').checked;

      endpointItems.forEach(item => {
        const endpoint = item.textContent.toLowerCase();
        let type = item.getAttribute('data-endpoint-type');
        const ips = (item.getAttribute('data-endpoint-ips') || '').toLowerCase();
        const macs = (item.getAttribute('data-endpoint-macs') || '').toLowerCase();

        // Check if matches search term (search in endpoint name, IPs, and MACs)
        const matchesSearch = normalizedSearch === ''
          || endpoint.includes(normalizedSearch)
          || ips.includes(normalizedSearch)
          || macs.includes(normalizedSearch);

        // Treat null/undefined/empty as 'other'
        if (!type || type === '') {
          type = 'other';
        }

        // Check if matches type filter
        let matchesType = false;
        if (type === 'local' && showLocal) matchesType = true;
        else if (type === 'gateway' && showGateway) matchesType = true;
        else if (type === 'internet' && showInternet) matchesType = true;
        else if (type === 'printer' && showPrinter) matchesType = true;
        else if (type === 'tv' && showTv) matchesType = true;
        else if (type === 'gaming' && showGaming) matchesType = true;
        else if (type === 'phone' && showPhone) matchesType = true;
        else if (type === 'virtualization' && showVirtualization) matchesType = true;
        else if (type === 'soundbar' && showSoundbar) matchesType = true;
        else if (type === 'appliance' && showAppliance) matchesType = true;
        else if (type === 'other' && showOther) matchesType = true;

        // Show only if matches both search AND type filter
        item.style.display = (matchesSearch && matchesType) ? 'block' : 'none';
      });

      // Apply endpoint limit and optionally update graph
      applyEndpointLimit(updateGraph);
    }

    // Update endpoint limit from slider
    function updateEndpointLimit(value) {
      document.getElementById('endpointLimitValue').textContent = value;
      localStorage.setItem('endpointLimit', value);

      // Save to URL parameters and trigger immediate reload
      const url = new URL(window.location.href);
      url.searchParams.set('endpoint_limit', value);
      window.location.href = url.toString();
    }

    // Apply endpoint limit to visible items
    function applyEndpointLimit(updateGraph = true) {
      const limit = parseInt(localStorage.getItem('endpointLimit') || '20');
      const endpointItems = document.querySelectorAll('#endpoints-container .list-item');

      let visibleCount = 0;
      endpointItems.forEach(item => {
        // Only count and limit items that are already visible (not filtered out)
        if (item.style.display !== 'none') {
          if (visibleCount < limit) {
            item.style.display = 'block';
            visibleCount++;
          } else {
            item.style.display = 'none';
          }
        }
      });

      // Update the graph to match the limited endpoint list (only if requested)
      if (updateGraph) {
        applyFilters(true);
      }
    }

    function selectScanInterval(interval) {
      const url = new URL(window.location.href);
      url.searchParams.set('scan_interval', interval);
      window.location.href = url.toString();
    }

    // Format bytes to human-readable format
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Format byte displays on page load
    document.addEventListener('DOMContentLoaded', function() {
      const bytesInElem = document.getElementById('bytes-in');
      const bytesOutElem = document.getElementById('bytes-out');

      if (bytesInElem) {
        const bytesIn = parseInt(bytesInElem.textContent);
        bytesInElem.textContent = formatBytes(bytesIn);
      }

      if (bytesOutElem) {
        const bytesOut = parseInt(bytesOutElem.textContent);
        bytesOutElem.textContent = formatBytes(bytesOut);
      }

      // Format endpoint bytes in the list
      document.querySelectorAll('.endpoint-bytes').forEach(elem => {
        const bytes = parseInt(elem.textContent);
        if (!isNaN(bytes) && bytes > 0) {
          elem.textContent = formatBytes(bytes);
        }
      });

      // Restore filter states from URL
      const urlParams = new URLSearchParams(window.location.search);
      const filterLocal = urlParams.get('filter_local');
      const filterGateway = urlParams.get('filter_gateway');
      const filterInternet = urlParams.get('filter_internet');
      const filterPrinter = urlParams.get('filter_printer');
      const filterTv = urlParams.get('filter_tv');
      const filterGaming = urlParams.get('filter_gaming');
      const filterPhone = urlParams.get('filter_phone');
      const filterVirtualization = urlParams.get('filter_virtualization');
      const filterSoundbar = urlParams.get('filter_soundbar');
      const filterAppliance = urlParams.get('filter_appliance');
      const filterOther = urlParams.get('filter_other');

      // Set checkbox states (default to checked if not specified)
      const localCheckbox = document.getElementById('filterLocal');
      const gatewayCheckbox = document.getElementById('filterGateway');
      const internetCheckbox = document.getElementById('filterInternet');
      const printerCheckbox = document.getElementById('filterPrinter');
      const tvCheckbox = document.getElementById('filterTv');
      const gamingCheckbox = document.getElementById('filterGaming');
      const phoneCheckbox = document.getElementById('filterPhone');
      const virtualizationCheckbox = document.getElementById('filterVirtualization');
      const soundbarCheckbox = document.getElementById('filterSoundbar');
      const applianceCheckbox = document.getElementById('filterAppliance');
      const otherCheckbox = document.getElementById('filterOther');

      if (localCheckbox && filterLocal !== null) {
        localCheckbox.checked = filterLocal === '1';
      }

      if (gatewayCheckbox && filterGateway !== null) {
        gatewayCheckbox.checked = filterGateway === '1';
      }

      if (internetCheckbox && filterInternet !== null) {
        internetCheckbox.checked = filterInternet === '1';
      }

      if (printerCheckbox && filterPrinter !== null) {
        printerCheckbox.checked = filterPrinter === '1';
      }

      if (tvCheckbox && filterTv !== null) {
        tvCheckbox.checked = filterTv === '1';
      }

      if (gamingCheckbox && filterGaming !== null) {
        gamingCheckbox.checked = filterGaming === '1';
      }

      if (phoneCheckbox && filterPhone !== null) {
        phoneCheckbox.checked = filterPhone === '1';
      }

      if (virtualizationCheckbox && filterVirtualization !== null) {
        virtualizationCheckbox.checked = filterVirtualization === '1';
      }

      if (soundbarCheckbox && filterSoundbar !== null) {
        soundbarCheckbox.checked = filterSoundbar === '1';
      }

      if (applianceCheckbox && filterAppliance !== null) {
        applianceCheckbox.checked = filterAppliance === '1';
      }

      if (otherCheckbox && filterOther !== null) {
        otherCheckbox.checked = filterOther === '1';
      }

      // Restore endpoint limit from URL or localStorage
      const urlParams2 = new URLSearchParams(window.location.search);
      const urlLimit = urlParams2.get('endpoint_limit');
      const savedLimit = urlLimit || localStorage.getItem('endpointLimit') || '20';
      const limitSlider = document.getElementById('endpointLimitSlider');
      const limitValue = document.getElementById('endpointLimitValue');

      if (limitSlider && limitValue) {
        limitSlider.value = savedLimit;
        limitValue.textContent = savedLimit;
        // Also save to localStorage if it came from URL
        if (urlLimit) {
          localStorage.setItem('endpointLimit', urlLimit);
        }
      }

      // Restore endpoint search filter from URL
      const filterEndpointsValue = urlParams.get('filter_endpoints');
      if (filterEndpointsValue) {
        const endpointsInput = document.getElementById('endpointSearchInput');
        if (endpointsInput) {
          endpointsInput.value = filterEndpointsValue;
          filterEndpointsList(filterEndpointsValue, true);
        }
      }

      // Restore right pane search filters from URL
      const filterHostnamesValue = urlParams.get('filter_hostnames');
      const filterIpsValue = urlParams.get('filter_ips');
      const filterMacsValue = urlParams.get('filter_macs');

      if (filterHostnamesValue) {
        const hostnamesInput = document.getElementById('hostnamesListSearch');
        if (hostnamesInput) {
          hostnamesInput.value = filterHostnamesValue;
          filterHostnamesList(filterHostnamesValue, true);
        }
      }

      if (filterIpsValue) {
        const ipsInput = document.getElementById('ipsListSearch');
        if (ipsInput) {
          ipsInput.value = filterIpsValue;
          filterIpsList(filterIpsValue, true);
        }
      }

      if (filterMacsValue) {
        const macsInput = document.getElementById('macsListSearch');
        if (macsInput) {
          macsInput.value = filterMacsValue;
          filterMacsList(filterMacsValue, true);
        }
      }

      // Restore protocol selection from URL
      const protocolValue = urlParams.get('protocol');
      if (protocolValue && typeof cy !== 'undefined') {
        selectedProtocol = protocolValue;
        // Wait for protocol badges to be rendered, then apply filter
        setTimeout(() => {
          const protocolBadge = document.querySelector(`.protocol-badge[data-protocol="${protocolValue}"]`);
          if (protocolBadge) {
            filterByProtocol(protocolValue, protocolBadge, true);
          }
        }, 100);
      }

      // Apply filters on page load (skip URL update to avoid redundant history)
      if (typeof cy !== 'undefined') {
        applyFilters(true);
      }

      // Apply endpoint limit on page load
      applyEndpointLimit();
    });

    // Update visible protocols in the overlay
    function updateVisibleProtocols() {
      // Get all visible protocols from visible edges
      const visibleProtocols = new Set();
      cy.edges().forEach(edge => {
        if (edge.style('display') === 'element') {
          const protocols = edge.data('protocol');
          if (protocols) {
            // Split comma-separated protocols and add each one
            protocols.split(',').forEach(proto => {
              if (proto) {
                visibleProtocols.add(proto);
              }
            });
          }
        }
      });

      // Sort protocols alphabetically
      const sortedProtocols = Array.from(visibleProtocols).sort();

      // Get the container
      const container = document.getElementById('protocols-container');

      // Clear existing badges
      container.innerHTML = '';

      // Create badges for all visible protocols
      if (sortedProtocols.length === 0) {
        container.innerHTML = '<div class="empty-state">No protocols</div>';
      } else {
        sortedProtocols.forEach(protocol => {
          const badge = document.createElement('div');
          badge.className = 'protocol-badge';
          badge.dataset.protocol = protocol;
          badge.textContent = protocol;
          badge.onclick = function() { filterByProtocol(protocol, this); };

          // Preserve selected/dimmed state if there's an active filter
          if (selectedProtocol) {
            if (protocol === selectedProtocol) {
              badge.classList.add('selected');
            } else {
              badge.classList.add('dimmed');
            }
          }

          container.appendChild(badge);
        });
      }
    }

    // Check if an IP is on the local network (private IP ranges)
    function isLocalIP(ip) {
      if (!ip) return false;

      // IPv4 private ranges
      const ipv4Private = [
        /^10\./,                    // 10.0.0.0/8
        /^172\.(1[6-9]|2[0-9]|3[01])\./, // 172.16.0.0/12
        /^192\.168\./,              // 192.168.0.0/16
        /^127\./,                   // 127.0.0.0/8 (loopback)
        /^169\.254\./,              // 169.254.0.0/16 (link-local)
        /^0\.0\.0\.0/,              // Unspecified
        /^255\.255\.255\.255/       // Broadcast
      ];

      // IPv6 private/local ranges
      const ipv6Private = [
        /^::1$/,                    // Loopback
        /^fe80:/i,                  // Link-local
        /^fc00:/i,                  // Unique local address
        /^fd00:/i,                  // Unique local address
        /^::$/                      // Unspecified
      ];

      for (let pattern of ipv4Private) {
        if (pattern.test(ip)) return true;
      }

      for (let pattern of ipv6Private) {
        if (pattern.test(ip)) return true;
      }

      return false;
    }

    // Select all device type filters
    function selectAllFilters() {
      document.getElementById('filterLocal').checked = true;
      document.getElementById('filterGateway').checked = true;
      document.getElementById('filterInternet').checked = true;
      document.getElementById('filterPrinter').checked = true;
      document.getElementById('filterTv').checked = true;
      document.getElementById('filterGaming').checked = true;
      document.getElementById('filterPhone').checked = true;
      document.getElementById('filterVirtualization').checked = true;
      document.getElementById('filterSoundbar').checked = true;
      document.getElementById('filterAppliance').checked = true;
      document.getElementById('filterOther').checked = true;
      applyFilters();
    }

    // Deselect all device type filters
    function selectNoneFilters() {
      document.getElementById('filterLocal').checked = false;
      document.getElementById('filterGateway').checked = false;
      document.getElementById('filterInternet').checked = false;
      document.getElementById('filterPrinter').checked = false;
      document.getElementById('filterTv').checked = false;
      document.getElementById('filterGaming').checked = false;
      document.getElementById('filterPhone').checked = false;
      document.getElementById('filterVirtualization').checked = false;
      document.getElementById('filterSoundbar').checked = false;
      document.getElementById('filterAppliance').checked = false;
      document.getElementById('filterOther').checked = false;
      applyFilters();
    }

    // Filter nodes by type
    function applyFilters(skipUrlUpdate = false) {
      // Get type filter states
      const showLocal = document.getElementById('filterLocal').checked;
      const showGateway = document.getElementById('filterGateway').checked;
      const showInternet = document.getElementById('filterInternet').checked;
      const showPrinter = document.getElementById('filterPrinter').checked;
      const showTv = document.getElementById('filterTv').checked;
      const showGaming = document.getElementById('filterGaming').checked;
      const showPhone = document.getElementById('filterPhone').checked;
      const showVirtualization = document.getElementById('filterVirtualization').checked;
      const showSoundbar = document.getElementById('filterSoundbar').checked;
      const showAppliance = document.getElementById('filterAppliance').checked;
      const showOther = document.getElementById('filterOther').checked;

      // Save filter state to URL
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        url.searchParams.set('filter_local', showLocal ? '1' : '0');
        url.searchParams.set('filter_gateway', showGateway ? '1' : '0');
        url.searchParams.set('filter_internet', showInternet ? '1' : '0');
        url.searchParams.set('filter_printer', showPrinter ? '1' : '0');
        url.searchParams.set('filter_tv', showTv ? '1' : '0');
        url.searchParams.set('filter_gaming', showGaming ? '1' : '0');
        url.searchParams.set('filter_phone', showPhone ? '1' : '0');
        url.searchParams.set('filter_virtualization', showVirtualization ? '1' : '0');
        url.searchParams.set('filter_soundbar', showSoundbar ? '1' : '0');
        url.searchParams.set('filter_appliance', showAppliance ? '1' : '0');
        url.searchParams.set('filter_other', showOther ? '1' : '0');
        window.history.replaceState({}, '', url);
      }

      // Helper function to check if an endpoint type matches current filters
      function matchesTypeFilter(type) {
        if (type === 'local' && showLocal) return true;
        if (type === 'gateway' && showGateway) return true;
        if (type === 'internet' && showInternet) return true;
        if (type === 'printer' && showPrinter) return true;
        if (type === 'tv' && showTv) return true;
        if (type === 'gaming' && showGaming) return true;
        if (type === 'phone' && showPhone) return true;
        if (type === 'virtualization' && showVirtualization) return true;
        if (type === 'soundbar' && showSoundbar) return true;
        if (type === 'appliance' && showAppliance) return true;
        if (type === 'other' && showOther) return true;
        return false;
      }

      // Check if a specific endpoint is selected from URL
      const urlParams = new URLSearchParams(window.location.search);
      const selectedEndpointFromUrl = urlParams.get('node');
      const isEndpointSelected = selectedEndpointFromUrl !== null && selectedEndpointFromUrl !== '';

      // Build set of endpoints that should be visible
      const visibleEndpointNames = new Set();

      // Always apply endpoint limit slider (both overall view and specific endpoint view)
      const limit = parseInt(localStorage.getItem('endpointLimit') || '20');
      const searchTerm = document.getElementById('endpointSearchInput')?.value.trim().toLowerCase() || '';

      // Build a list of graph nodes with their sidebar data
      const nodeData = [];
      cy.nodes().forEach(node => {
        const nodeName = node.data('id');
        let type = node.data('type');

        // Treat null/undefined/empty as 'other'
        if (!type || type === '') {
          type = 'other';
        }

        // Find corresponding sidebar item for search data
        const sidebarItem = document.querySelector(`#endpoints-container .list-item[data-endpoint="${nodeName}"]`);
        const endpointText = sidebarItem ? sidebarItem.textContent.toLowerCase() : nodeName.toLowerCase();
        const ips = sidebarItem ? (sidebarItem.getAttribute('data-endpoint-ips') || '').toLowerCase() : '';
        const macs = sidebarItem ? (sidebarItem.getAttribute('data-endpoint-macs') || '').toLowerCase() : '';

        // Check if matches search term
        const matchesSearch = searchTerm === ''
          || endpointText.includes(searchTerm)
          || ips.includes(searchTerm)
          || macs.includes(searchTerm);

        // Check if matches type filter
        const matchesType = matchesTypeFilter(type);

        if (matchesSearch && matchesType) {
          nodeData.push({ name: nodeName, type: type });
        }
      });

      // Apply limit to the filtered list
      for (let i = 0; i < Math.min(limit, nodeData.length); i++) {
        visibleEndpointNames.add(nodeData[i].name);
      }

      // Filter nodes in graph based on the visible set
      cy.nodes().forEach(node => {
        let type = node.data('type');
        const nodeName = node.data('id');

        // Treat null/undefined/empty as 'other'
        if (!type || type === '') {
          type = 'other';
        }

        // Check type filter
        const typeMatch = matchesTypeFilter(type);

        // Check if endpoint is in the visible list
        const inVisibleList = visibleEndpointNames.has(nodeName);

        // Apply filter: must match type AND be in visible list
        if (typeMatch && inVisibleList) {
          node.style('display', 'element');
        } else {
          node.style('display', 'none');
        }
      });

      // Hide edges connected to hidden nodes
      cy.edges().forEach(edge => {
        const sourceVisible = edge.source().style('display') === 'element';
        const targetVisible = edge.target().style('display') === 'element';
        edge.style('display', sourceVisible && targetVisible ? 'element' : 'none');
      });

      // Filter endpoints in sidebar list (reapply search filter to respect type filters)
      const searchInput = document.getElementById('endpointSearchInput');
      if (searchInput) {
        filterEndpointsList(searchInput.value, true);
      }

      // Filter IPs and hostnames in endpoint details based on internet filter
      if (!showInternet) {
        // Hide internet-facing IPs
        const ipItems = document.querySelectorAll('#ips-container .hostname-item');
        ipItems.forEach(item => {
          const ip = item.textContent.trim();
          if (!isLocalIP(ip)) {
            item.style.display = 'none';
          } else {
            item.style.display = 'block';
          }
        });

        // Note: Hostnames are harder to classify without backend help,
        // so we'll keep them visible for now unless you want to filter more aggressively
      } else {
        // Show all IPs when internet filter is enabled
        const ipItems = document.querySelectorAll('#ips-container .hostname-item');
        ipItems.forEach(item => {
          item.style.display = 'block';
        });
      }

      // Update visible protocols in overlay
      updateVisibleProtocols();

      // Check if any communications are visible after filtering
      checkForCommunications();

      // Re-layout visible elements to prevent flower/disjointed pattern
      relayoutVisibleElements();
    }

    // Debounced re-layout to prevent excessive layout runs
    const relayoutVisibleElements = debounce(() => {
      const visibleElements = cy.elements().filter(ele => ele.style('display') === 'element');
      if (visibleElements.length > 0) {
        visibleElements.layout({
          name: 'cose',
          nodeRepulsion: 400000,
          nodeDimensionsIncludeLabels: true,
          padding: 80,
          animate: true,
          animationDuration: 300,
          fit: true
        }).run();
      }
    }, 100);

    // Filter hostnames list in right pane
    function filterHostnamesList(searchTerm, skipUrlUpdate = false) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const hostnameItems = document.querySelectorAll('#hostnames-container .hostname-item');

      // Save to URL parameters
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        if (normalizedSearch) {
          url.searchParams.set('filter_hostnames', searchTerm);
        } else {
          url.searchParams.delete('filter_hostnames');
        }
        window.history.replaceState({}, '', url);
      }

      hostnameItems.forEach(item => {
        const hostname = item.textContent.toLowerCase();
        if (normalizedSearch === '' || hostname.includes(normalizedSearch)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    }

    // Filter IPs list in right pane
    function filterIpsList(searchTerm, skipUrlUpdate = false) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const ipItems = document.querySelectorAll('#ips-container .hostname-item');

      // Save to URL parameters
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        if (normalizedSearch) {
          url.searchParams.set('filter_ips', searchTerm);
        } else {
          url.searchParams.delete('filter_ips');
        }
        window.history.replaceState({}, '', url);
      }

      ipItems.forEach(item => {
        const ip = item.textContent.toLowerCase();
        if (normalizedSearch === '' || ip.includes(normalizedSearch)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    }

    // Filter MACs list in right pane
    function filterMacsList(searchTerm, skipUrlUpdate = false) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const macItems = document.querySelectorAll('#macs-container .hostname-item');

      // Save to URL parameters
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        if (normalizedSearch) {
          url.searchParams.set('filter_macs', searchTerm);
        } else {
          url.searchParams.delete('filter_macs');
        }
        window.history.replaceState({}, '', url);
      }

      macItems.forEach(item => {
        const mac = item.textContent.toLowerCase();
        if (normalizedSearch === '' || mac.includes(normalizedSearch)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    }


    // Global variable to track selected protocol
    let selectedProtocol = null;

    // Apply combined protocol and port filters
    function applyCombinedFilters() {
      const relevantNodeIds = new Set();

      // Check each edge to see if it matches ALL active filters
      cy.edges().forEach(edge => {
        let matchesProtocol = true;
        let matchesPort = true;

        // Check protocol filter
        if (selectedProtocol) {
          const edgeProtocols = edge.data('protocol').split(',');
          matchesProtocol = edgeProtocols.includes(selectedProtocol);
        }

        // Check port filter
        if (selectedPort) {
          const portStr = String(selectedPort);
          const srcPorts = edge.data('src_port');
          const dstPorts = edge.data('dst_port');
          const srcPortList = srcPorts ? String(srcPorts).split(',').map(p => p.trim()) : [];
          const dstPortList = dstPorts ? String(dstPorts).split(',').map(p => p.trim()) : [];
          matchesPort = srcPortList.includes(portStr) || dstPortList.includes(portStr);
        }

        // Edge must match ALL active filters
        if (matchesProtocol && matchesPort) {
          relevantNodeIds.add(edge.source().id());
          relevantNodeIds.add(edge.target().id());
          edge.style('display', 'element');
          edge.style('opacity', 0.8);
          edge.style('width', 2);
        } else {
          edge.style('display', 'none');
        }
      });

      // Show/hide nodes based on relevant edges
      cy.nodes().forEach(node => {
        if (relevantNodeIds.has(node.id())) {
          node.style('display', 'element');
        } else {
          node.style('display', 'none');
        }
      });
    }

    // Filter graph by protocol
    function filterByProtocol(protocol, element, skipUrlUpdate = false) {
      selectedProtocol = protocol;

      // Save to URL parameters
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        url.searchParams.set('protocol', protocol);
        window.history.replaceState({}, '', url);
      }

      // Apply combined filters
      applyCombinedFilters();

      // Update UI - highlight selected protocol badge, dim others
      document.querySelectorAll('.protocol-badge').forEach(badge => {
        if (badge.dataset.protocol === protocol) {
          badge.classList.add('selected');
          badge.classList.remove('dimmed');
        } else {
          badge.classList.remove('selected');
          badge.classList.add('dimmed');
        }
      });

      // Show clear filter button
      document.querySelector('.clear-filter-btn').style.display = 'block';
    }

    // Clear protocol filter
    function clearProtocolFilter() {
      selectedProtocol = null;

      // Remove from URL parameters
      const url = new URL(window.location.href);
      url.searchParams.delete('protocol');
      window.history.replaceState({}, '', url);

      // Reset protocol badges
      document.querySelectorAll('.protocol-badge').forEach(badge => {
        badge.classList.remove('selected');
        badge.classList.remove('dimmed');
      });

      // Hide clear filter button
      document.querySelector('.clear-filter-btn').style.display = 'none';

      // If port filter is still active, apply it; otherwise reset everything
      if (selectedPort) {
        applyCombinedFilters();
      } else {
        // Reset all nodes and edges to visible
        cy.nodes().forEach(node => {
          node.style('display', 'element');
        });
        cy.edges().forEach(edge => {
          edge.style('display', 'element');
          edge.style('opacity', 0.4);
          edge.style('width', 1.5);
        });
        // Re-apply type filters
        applyFilters();
      }
    }

    // Filter graph by port
    let selectedPort = null;
    function filterByPort(port, element, skipUrlUpdate = false) {
      selectedPort = port;
      const portStr = String(port);

      // Save to URL parameters
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        url.searchParams.set('port', portStr);
        window.history.replaceState({}, '', url);
      }

      // Apply combined filters
      applyCombinedFilters();

      // Update UI - highlight selected port badge, dim others
      document.querySelectorAll('[data-port]').forEach(badge => {
        if (badge.dataset.port == port) {
          badge.classList.add('selected');
          badge.classList.remove('dimmed');
        } else {
          badge.classList.remove('selected');
          badge.classList.add('dimmed');
        }
      });

      // Show clear filter button
      document.querySelector('.clear-port-filter-btn').style.display = 'block';

      // Check if any communications are visible
      checkForCommunications();
    }

    // Clear port filter
    function clearPortFilter() {
      selectedPort = null;

      // Remove from URL parameters
      const url = new URL(window.location.href);
      url.searchParams.delete('port');
      window.history.replaceState({}, '', url);

      // Reset port badges
      document.querySelectorAll('[data-port]').forEach(badge => {
        badge.classList.remove('selected');
        badge.classList.remove('dimmed');
      });

      // Hide clear filter button
      document.querySelector('.clear-port-filter-btn').style.display = 'none';

      // If protocol filter is still active, apply it; otherwise reset everything
      if (selectedProtocol) {
        applyCombinedFilters();
      } else {
        // Reset all nodes and edges to visible
        cy.nodes().forEach(node => {
          node.style('display', 'element');
        });
        cy.edges().forEach(edge => {
          edge.style('display', 'element');
          edge.style('opacity', 0.4);
          edge.style('width', 1.5);
        });
        // Re-apply type filters
        applyFilters();
      }

      // Check if any communications are visible
      checkForCommunications();
    }

    // Copy to clipboard with visual feedback
    function copyToClipboard(text, element) {
      navigator.clipboard.writeText(text).then(() => {
        const originalBg = element.style.background;
        element.style.background = 'var(--accent-success)';
        element.style.color = 'white';
        setTimeout(() => {
          element.style.background = originalBg;
          element.style.color = '';
        }, 500);
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }

    // Initialize Cytoscape graph
    var cy = cytoscape({
      container: document.getElementById('cy'),
      boxSelectionEnabled: false,
      autounselectify: true,
      layout: {
        name: 'cose',
        nodeRepulsion: 400000,
        nodeDimensionsIncludeLabels: true,
        padding: 80,
        animate: true,
        animationDuration: 500
      },
      elements: [
        {% for endpoint in endpoints %}
          { data: {
              id: '{{ endpoint | safe }}',
              {% if endpoint == hostname %}type: 'local',
              {% elif endpoint_types[endpoint] %}type: '{{ endpoint_types[endpoint] }}',
              {% else %}type: 'other',
              {% endif %}
              {% if endpoint == selected_node %}selected: true,{% endif %}
            }
          },
        {% endfor %}
        {% for comm in communications %}
          {% if comm.src_hostname != comm.dst_hostname %}
          { data: {
            id: '{{ comm.sub_protocol | safe }}-{{ comm.src_hostname | safe }}-{{ comm.dst_hostname | safe }}',
            source: '{{ comm.src_hostname | safe }}',
            target: '{{ comm.dst_hostname | safe }}',
            label: '{{ comm.sub_protocol | safe }}',
            protocol: '{{ comm.sub_protocol | safe }}',
            src_port: {% if comm.src_port %}'{{ comm.src_port | safe }}'{% else %}null{% endif %},
            dst_port: {% if comm.dst_port %}'{{ comm.dst_port | safe }}'{% else %}null{% endif %}
          }},
          {% endif %}
        {% endfor %}
      ],
      style: [
        {
          selector: 'node',
          style: {
            'label': function(ele) { return 'üíª\n' + ele.data('id'); },
            'shape': 'round-rectangle',
            'background-color': '#1e293b',
            'font-size': 28,
            'font-weight': 600,
            'text-valign': 'center',
            'text-halign': 'center',
            'text-wrap': 'wrap',
            'text-max-width': '280px',
            'text-outline-width': 2,
            'text-outline-color': '#0f172a',
            'color': '#f1f5f9',
            'width': 150,
            'height': 150,
            'border-width': 2,
            'border-color': '#64748b'
          }
        },
        {
          selector: 'node[type = "local"]',
          style: {
            'label': function(ele) { return 'üñ•Ô∏è\n' + ele.data('id'); },
            'background-color': '#2d1b4e',
            'border-color': '#8b5cf6',
            'border-width': 3
          }
        },
        {
          selector: 'node[type = "gateway"]',
          style: {
            'label': function(ele) { return 'üåê\n' + ele.data('id'); },
            'background-color': '#422006',
            'border-color': '#f59e0b',
            'border-width': 3
          }
        },
        {
          selector: 'node[type = "internet"]',
          style: {
            'label': function(ele) { return 'üåç\n' + ele.data('id'); },
            'background-color': '#083344',
            'border-color': '#06b6d4',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "printer"]',
          style: {
            'label': function(ele) { return 'üñ®Ô∏è\n' + ele.data('id'); },
            'background-color': '#1e3a28',
            'border-color': '#10b981',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "tv"]',
          style: {
            'label': function(ele) { return 'üì∫\n' + ele.data('id'); },
            'background-color': '#3c1f5f',
            'border-color': '#c084fc',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "gaming"]',
          style: {
            'label': function(ele) { return 'üéÆ\n' + ele.data('id'); },
            'background-color': '#5c1c2e',
            'border-color': '#f43f5e',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "phone"]',
          style: {
            'label': function(ele) { return 'üì±\n' + ele.data('id'); },
            'background-color': '#083333',
            'border-color': '#14b8a6',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "virtualization"]',
          style: {
            'label': function(ele) { return 'üñ•\n' + ele.data('id'); },
            'background-color': '#1e293b',
            'border-color': '#94a3b8',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "soundbar"]',
          style: {
            'label': function(ele) { return 'üîä\n' + ele.data('id'); },
            'background-color': '#312e81',
            'border-color': '#818cf8',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "appliance"]',
          style: {
            'label': function(ele) { return 'üè†\n' + ele.data('id'); },
            'background-color': '#422006',
            'border-color': '#fb923c',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "other"]',
          style: {
            'label': function(ele) { return '‚ùì\n' + ele.data('id'); },
            'background-color': '#374151',
            'border-color': '#9ca3af',
            'border-width': 2
          }
        },
        {
          selector: 'node[selected = "true"]',
          style: {
            'border-width': 4,
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "local"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "gateway"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "internet"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "printer"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "tv"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "gaming"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "phone"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "virtualization"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'edge',
          style: {
            'target-arrow-shape': 'triangle',
            'label': 'data(label)',
            'curve-style': 'bezier',
            'width': 1.5,
            'opacity': 0.4,
            'line-color': '#475569',
            'target-arrow-color': '#475569',
            'font-size': 0,
            'color': '#94a3b8',
            'text-outline-width': 2,
            'text-outline-color': '#0f172a'
          }
        },
        {
          selector: 'edge:selected',
          style: {
            'font-size': 9,
            'opacity': 0.8,
            'width': 2
          }
        }
      ],
    });

    // Check if there are any visible communications and show message if empty
    function checkForCommunications() {
      const noCommsMsg = document.getElementById('no-communications-msg');

      // Count all visible nodes
      let visibleNodes = 0;
      cy.nodes().forEach(node => {
        if (node.style('display') === 'element') {
          visibleNodes++;
        }
      });

      // If no nodes are visible (all filtered out), show message
      if (visibleNodes === 0) {
        noCommsMsg.style.display = 'block';
        return;
      }

      // Check if a specific endpoint is selected
      const selectedNode = cy.nodes('[selected = "true"]');

      // Hide message if no specific endpoint is selected
      if (selectedNode.length === 0) {
        noCommsMsg.style.display = 'none';
        return;
      }

      // Count visible edges connected to the selected node
      let visibleEdges = 0;
      selectedNode.connectedEdges().forEach(edge => {
        if (edge.style('display') === 'element') {
          visibleEdges++;
        }
      });

      if (visibleEdges === 0) {
        noCommsMsg.style.display = 'block';
      } else {
        noCommsMsg.style.display = 'none';
      }
    }

    // Initialize visible protocols on page load
    updateVisibleProtocols();
    checkForCommunications();

    // Node click handler
    cy.on('tap', 'node', function(event) {
      var nodeId = event.target.id();
      var currentUrl = new URL(window.location.href);
      var currentNodeParam = currentUrl.searchParams.get('node');

      if (currentNodeParam !== nodeId) {
        currentUrl.searchParams.set('node', nodeId);
        window.location.href = currentUrl.toString();
      }
    });

    // Scroll to section in details panel
    function scrollToSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // Zoom controls
    function zoomIn() {
      cy.zoom({
        level: cy.zoom() * 1.2,
        renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
      });
    }

    function zoomOut() {
      cy.zoom({
        level: cy.zoom() / 1.2,
        renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
      });
    }

    function fitGraph() {
      cy.fit(cy.elements(), 50);
    }

    // Device type reclassification
    let savedRefreshInterval = null;

    function toggleDeviceTypeDropdown(event) {
      event.stopPropagation();
      const dropdown = document.getElementById('device-type-dropdown');
      const isOpening = !dropdown.classList.contains('open');

      if (isOpening) {
        // Pause auto-refresh while dropdown is open
        if (refreshIntervalId) {
          savedRefreshInterval = document.getElementById('refreshInterval').value;
          clearInterval(refreshIntervalId);
          refreshIntervalId = null;
        }
      }

      dropdown.classList.toggle('open');
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const dropdown = document.getElementById('device-type-dropdown');
      const btn = document.getElementById('device-type-btn');
      if (dropdown && !dropdown.contains(event.target) && !btn.contains(event.target)) {
        dropdown.classList.remove('open');
        // Resume auto-refresh if it was paused
        if (savedRefreshInterval && savedRefreshInterval !== '0') {
          updateRefreshInterval(savedRefreshInterval);
          savedRefreshInterval = null;
        }
      }
    });

    async function reclassifyEndpoint(deviceType) {
      const endpointName = '{{ endpoint | safe }}';
      const dropdown = document.getElementById('device-type-dropdown');
      dropdown.classList.remove('open');

      try {
        const response = await fetch('/api/endpoint/classify', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            endpoint_name: endpointName,
            device_type: deviceType === 'auto' ? null : deviceType,
          }),
        });

        const result = await response.json();
        if (result.success) {
          window.location.reload();
        } else {
          alert('Failed to update device type: ' + result.message);
        }
      } catch (error) {
        alert('Failed to update device type. Please try again.');
      }
    }

    // Auto-refresh management
    let refreshIntervalId = null;

    function updateRefreshInterval(seconds) {
      // Save preference
      localStorage.setItem('refreshInterval', seconds);

      // Clear existing interval
      if (refreshIntervalId) {
        clearInterval(refreshIntervalId);
        refreshIntervalId = null;
      }

      // Update pulse indicator and button state
      const pulse = document.querySelector('.pulse');
      const toggleBtn = document.getElementById('refreshToggleBtn');

      if (seconds == 0) {
        pulse.classList.add('stopped');
        toggleBtn.innerHTML = '‚ñ∂Ô∏è';
        toggleBtn.classList.add('play');
        toggleBtn.title = 'Start auto-refresh';
      } else {
        pulse.classList.remove('stopped');
        toggleBtn.innerHTML = '‚èπÔ∏è';
        toggleBtn.classList.remove('play');
        toggleBtn.title = 'Stop auto-refresh';

        // Set new interval - behavior depends on active tab
        refreshIntervalId = setInterval(() => {
          if (activeTab === 'dns') {
            // Refresh DNS entries without page reload
            refreshDnsEntries();
          } else {
            // Reload page for network tab
            window.location.reload();
          }
        }, seconds * 1000);
      }
    }

    // Toggle auto-refresh on/off
    function toggleRefresh() {
      const refreshSelect = document.getElementById('refreshInterval');
      const currentValue = refreshSelect.value;

      if (currentValue == '0') {
        // Currently stopped, start with default 5 seconds
        const lastInterval = localStorage.getItem('lastRefreshInterval') || '5';
        refreshSelect.value = lastInterval;
        updateRefreshInterval(lastInterval);
      } else {
        // Currently running, stop it
        localStorage.setItem('lastRefreshInterval', currentValue);
        refreshSelect.value = '0';
        updateRefreshInterval('0');
      }
    }

    // Manual refresh - respects current tab
    function manualRefresh() {
      if (activeTab === 'dns') {
        refreshDnsEntries();
      } else {
        window.location.reload();
      }
    }

    // Initialize refresh interval on page load
    window.addEventListener('DOMContentLoaded', () => {
      const savedInterval = localStorage.getItem('refreshInterval') || '5';
      document.getElementById('refreshInterval').value = savedInterval;
      updateRefreshInterval(savedInterval);
    });
  </script>
</body>
</html>
