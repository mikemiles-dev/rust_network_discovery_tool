<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Network Discovery Tool</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --accent-primary: #3b82f6;
      --accent-secondary: #8b5cf6;
      --accent-success: #10b981;
      --border-color: #334155;
      --shadow: rgba(0, 0, 0, 0.3);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow: hidden;
    }

    /* Header */
    header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 8px var(--shadow);
      z-index: 100;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .controls {
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .control-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    select {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 150px;
    }

    select:hover {
      border-color: var(--accent-primary);
      background: var(--bg-secondary);
    }

    select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Main Layout */
    .container {
      display: flex;
      height: calc(100vh - 73px);
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      background: rgba(30, 41, 59, 0.85);
      backdrop-filter: blur(12px);
      border-right: 1px solid rgba(51, 65, 85, 0.6);
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
    }

    .card {
      background: rgba(51, 65, 85, 0.5);
      border-radius: 0.75rem;
      padding: 1rem;
      border: 1px solid rgba(51, 65, 85, 0.6);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .card-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
    }

    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    input[type="text"] {
      flex: 1;
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(51, 65, 85, 0.6);
      color: var(--text-primary);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    button {
      background: var(--accent-primary);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    button:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
    }

    button.secondary:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-primary);
      box-shadow: none;
    }

    .list-box {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      max-height: 100px;
      overflow-y: auto;
      margin-bottom: 0.375rem;
    }

    .list-item {
      background: rgba(51, 65, 85, 0.5);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid rgba(51, 65, 85, 0.6);
      font-family: 'Monaco', 'Courier New', monospace;
    }

    .list-item:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .list-item:active {
      transform: translateY(0);
    }

    .list-item.selected {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }

    .section {
      margin-bottom: 0.75rem;
    }

    .section:last-child {
      margin-bottom: 0;
    }

    /* Graph Container */
    #graph-container {
      flex: 1;
      position: relative;
      background: var(--bg-primary);
    }

    #cy {
      width: 100%;
      height: 100%;
      padding-right: 320px;
    }

    /* Stats Badge */
    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.375rem;
      margin-top: 0.5rem;
    }

    .stat-badge {
      background: rgba(15, 23, 42, 0.5);
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.6875rem;
      color: var(--text-secondary);
    }

    .stat-number {
      color: var(--accent-primary);
      font-weight: 600;
    }

    .pulse {
      width: 8px;
      height: 8px;
      background: var(--accent-success);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--border-color);
    }

    /* Empty state */
    .empty-state {
      color: var(--text-secondary);
      font-size: 0.75rem;
      font-style: italic;
      padding: 0.375rem 0.5rem;
    }

    /* Range slider styling */
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      border: 2px solid rgba(15, 23, 42, 0.8);
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      border: 2px solid rgba(15, 23, 42, 0.8);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #10b981;
    }

    input[type="range"]::-moz-range-thumb:hover {
      background: #10b981;
    }

    /* Protocols Overlay */
    .protocols-overlay {
      position: absolute;
      top: 1rem;
      right: 1rem;
      width: 340px;
      height: calc(100vh - 120px);
      background: rgba(30, 41, 59, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(51, 65, 85, 0.6);
      border-radius: 0.75rem;
      padding: 1rem;
      z-index: 10;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      overflow-y: auto;
    }

    .overlay-header {
      font-size: 0.875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      padding-bottom: 0.5rem;
      margin-bottom: 0.75rem;
      border-bottom: 1px solid rgba(51, 65, 85, 0.6);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .overlay-header:not(:first-child) {
      margin-top: 0.75rem;
    }

    .clear-filter-btn {
      background: var(--accent-secondary);
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.625rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .clear-filter-btn:hover {
      background: #7c3aed;
      transform: translateY(-1px);
    }

    .overlay-content {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .protocol-badge {
      background: rgba(51, 65, 85, 0.5);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid rgba(51, 65, 85, 0.6);
      white-space: nowrap;
    }

    .protocol-badge:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .protocol-badge:active {
      transform: translateY(0);
    }

    .protocol-badge.selected {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }

    .protocol-badge.dimmed {
      opacity: 0.4;
    }

    .overlay-hostnames {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      margin-bottom: 0.75rem;
    }

    .hostname-item {
      background: rgba(51, 65, 85, 0.5);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid rgba(51, 65, 85, 0.6);
      font-family: 'Monaco', 'Courier New', monospace;
    }

    .hostname-item:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .hostname-item:active {
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">‚ö° Rust Network Discovery Tool</div>
    <div class="controls">
      <div class="control-group">
        <label class="control-label">Time Range</label>
        <select id="scanInterval" onchange="selectScanInterval(this.value)">
          <option value="5" {% if scan_interval == 5 %}selected{% endif %}>5 Minutes</option>
          <option value="15" {% if scan_interval == 15 %}selected{% endif %}>15 Minutes</option>
          <option value="30" {% if scan_interval == 30 %}selected{% endif %}>30 Minutes</option>
          <option value="60" {% if scan_interval == 60 %}selected{% endif %}>1 Hour</option>
          <option value="240" {% if scan_interval == 240 %}selected{% endif %}>4 Hours</option>
          <option value="1440" {% if scan_interval == 1440 %}selected{% endif %}>1 Day</option>
        </select>
      </div>
      <div class="control-group">
        <label class="control-label">Auto-Refresh</label>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <select id="refreshInterval" onchange="updateRefreshInterval(this.value)">
            <option value="0">Off</option>
            <option value="3">3 seconds</option>
            <option value="5" selected>5 seconds</option>
            <option value="10">10 seconds</option>
            <option value="30">30 seconds</option>
            <option value="60">1 minute</option>
          </select>
          <div class="pulse"></div>
        </div>
      </div>
    </div>
  </header>

  <div class="container">
    <aside class="sidebar">
      <div class="card">
        <div class="card-title" style="margin-bottom: 0; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(51, 65, 85, 0.6);">Endpoints</div>

        <!-- Filters -->
        <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem; margin-bottom: 0.5rem; flex-wrap: wrap;">
          <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; cursor: pointer; padding: 0.25rem 0.5rem; background: rgba(30, 41, 59, 0.6); border-radius: 0.375rem; border: 1px solid rgba(51, 65, 85, 0.6);">
            <input type="checkbox" id="filterGateway" checked onchange="applyFilters()" style="cursor: pointer;">
            <span>üåê Gateway</span>
          </label>
          <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; cursor: pointer; padding: 0.25rem 0.5rem; background: rgba(30, 41, 59, 0.6); border-radius: 0.375rem; border: 1px solid rgba(51, 65, 85, 0.6);">
            <input type="checkbox" id="filterInternet" checked onchange="applyFilters()" style="cursor: pointer;">
            <span>üåç Internet</span>
          </label>
        </div>

        <!-- Endpoint Limit Slider -->
        <div style="margin-bottom: 0.75rem;">
          <label style="display: flex; justify-content: space-between; align-items: center; font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.375rem;">
            <span>Show endpoints:</span>
            <span id="endpointLimitValue" style="color: var(--text-primary); font-weight: 500;">20</span>
          </label>
          <input type="range" id="endpointLimitSlider" min="10" max="100" value="20" step="10"
                 oninput="updateEndpointLimit(this.value)"
                 style="width: 100%; cursor: pointer; height: 4px; background: rgba(51, 65, 85, 0.6); border-radius: 2px; appearance: none; outline: none;">
        </div>

        <input type="text" id="endpointSearchInput" placeholder="Search endpoints..."
               oninput="filterEndpointsList(this.value)"
               style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem; margin-bottom: 0.75rem;">
        <div class="list-box" id="endpoints-container" style="max-height: calc(100vh - 200px);">
          {% for node in dropdown_endpoints %}
          <div class="list-item {% if node == selected_node %}selected{% endif %}"
               onclick="selectNode('{{ node | safe }}')"
               data-endpoint="{{ node | safe }}"
               data-endpoint-type="{% if node == hostname %}local{% elif endpoint_types[node] == "gateway" %}gateway{% elif endpoint_types[node] == "internet" %}internet{% else %}local{% endif %}">
            {% if node == hostname %}üñ•Ô∏è{% elif endpoint_types[node] == "gateway" %}üåê{% elif endpoint_types[node] == "internet" %}üåç{% else %}üíª{% endif %} {{ node | safe }}
          </div>
          {% endfor %}
        </div>
      </div>
    </aside>

    <main id="graph-container">
      <div id="cy"></div>

      <!-- Protocols Overlay -->
      <div class="protocols-overlay">
        <!-- Endpoint Details -->
        <div class="overlay-header">
          Endpoint Details
        </div>
        <div style="margin-bottom: 0.75rem;">
          <div class="stats">
            <div class="stat-badge">IPs: <span class="stat-number">{{ ips|length }}</span></div>
            <div class="stat-badge">MACs: <span class="stat-number">{{ macs|length }}</span></div>
            <div class="stat-badge">Hosts: <span class="stat-number">{{ hostnames|length }}</span></div>
            <div class="stat-badge">Protocols: <span class="stat-number">{{ protocols|length }}</span></div>
          </div>
          <div class="stats" style="margin-top: 0.5rem;">
            <div class="stat-badge">‚¨áÔ∏è In: <span class="stat-number" id="bytes-in">{{ bytes_in }}</span></div>
            <div class="stat-badge">‚¨ÜÔ∏è Out: <span class="stat-number" id="bytes-out">{{ bytes_out }}</span></div>
          </div>
        </div>

        <div class="overlay-header">
          Protocols
          <button class="clear-filter-btn" onclick="clearProtocolFilter()" style="display: none;">Clear Filter</button>
        </div>
        <div class="overlay-content" id="protocols-container">
          <!-- Protocols will be dynamically generated from graph data -->
        </div>

        <div class="overlay-header">
          Hostnames
        </div>
        <div style="margin-bottom: 0.75rem;">
          <input type="text" id="hostnamesListSearch" placeholder="Filter hostnames..."
                 oninput="filterHostnamesList(this.value)"
                 style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
        </div>
        <div class="overlay-hostnames" id="hostnames-container">
          {% if hostnames %}
            {% for hostname in hostnames %}
            <div class="hostname-item" onclick="copyToClipboard('{{ hostname | safe }}', this)">{{ hostname | safe }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No hostnames</div>
          {% endif %}
        </div>

        <!-- IP Addresses -->
        <div class="overlay-header">
          IP Addresses
        </div>
        <div style="margin-bottom: 0.75rem;">
          <input type="text" id="ipsListSearch" placeholder="Filter IPs..."
                 oninput="filterIpsList(this.value)"
                 style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
        </div>
        <div class="overlay-hostnames" id="ips-container">
          {% if ips %}
            {% for ip in ips %}
            <div class="hostname-item" onclick="copyToClipboard('{{ ip | safe }}', this)">{{ ip | safe }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No IP addresses</div>
          {% endif %}
        </div>

        <!-- MAC Addresses -->
        <div class="overlay-header">
          MAC Addresses
        </div>
        <div style="margin-bottom: 0.75rem;">
          <input type="text" id="macsListSearch" placeholder="Filter MACs..."
                 oninput="filterMacsList(this.value)"
                 style="width: 100%; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(51, 65, 85, 0.6); color: var(--text-primary); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
        </div>
        <div class="overlay-hostnames" id="macs-container">
          {% if macs %}
            {% for mac in macs %}
            <div class="hostname-item" onclick="copyToClipboard('{{ mac | safe }}', this)">{{ mac | safe }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No MAC addresses</div>
          {% endif %}
        </div>
      </div>
    </main>
  </div>

  <script>
    // Navigation functions
    function selectNode(nodeId) {
      const url = new URL(window.location.href);
      url.searchParams.set('node', nodeId);
      window.location.href = url.toString();
    }

    // Filter endpoints list in sidebar
    function filterEndpointsList(searchTerm) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const endpointItems = document.querySelectorAll('#endpoints-container .list-item');

      // Get current filter states
      const showGateway = document.getElementById('filterGateway').checked;
      const showInternet = document.getElementById('filterInternet').checked;

      endpointItems.forEach(item => {
        const endpoint = item.textContent.toLowerCase();
        const type = item.getAttribute('data-endpoint-type');

        // Check if matches search term
        const matchesSearch = normalizedSearch === '' || endpoint.includes(normalizedSearch);

        // Check if matches type filter
        let matchesType = true;
        if (type === 'gateway' && !showGateway) matchesType = false;
        else if (type === 'internet' && !showInternet) matchesType = false;

        // Show only if matches both search AND type filter
        item.style.display = (matchesSearch && matchesType) ? 'block' : 'none';
      });

      // Apply endpoint limit
      applyEndpointLimit();
    }

    // Update endpoint limit from slider
    function updateEndpointLimit(value) {
      document.getElementById('endpointLimitValue').textContent = value;
      localStorage.setItem('endpointLimit', value);
      applyEndpointLimit();
    }

    // Apply endpoint limit to visible items
    function applyEndpointLimit() {
      const limit = parseInt(localStorage.getItem('endpointLimit') || '20');
      const endpointItems = document.querySelectorAll('#endpoints-container .list-item');

      let visibleCount = 0;
      endpointItems.forEach(item => {
        // Only count and limit items that are already visible (not filtered out)
        if (item.style.display !== 'none') {
          if (visibleCount < limit) {
            item.style.display = 'block';
            visibleCount++;
          } else {
            item.style.display = 'none';
          }
        }
      });
    }

    function selectScanInterval(interval) {
      const url = new URL(window.location.href);
      url.searchParams.set('scan_interval', interval);
      window.location.href = url.toString();
    }

    // Format bytes to human-readable format
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Format byte displays on page load
    document.addEventListener('DOMContentLoaded', function() {
      const bytesInElem = document.getElementById('bytes-in');
      const bytesOutElem = document.getElementById('bytes-out');

      if (bytesInElem) {
        const bytesIn = parseInt(bytesInElem.textContent);
        bytesInElem.textContent = formatBytes(bytesIn);
      }

      if (bytesOutElem) {
        const bytesOut = parseInt(bytesOutElem.textContent);
        bytesOutElem.textContent = formatBytes(bytesOut);
      }

      // Restore filter states from URL
      const urlParams = new URLSearchParams(window.location.search);
      const filterGateway = urlParams.get('filter_gateway');
      const filterInternet = urlParams.get('filter_internet');

      // Set checkbox states (default to checked if not specified)
      const gatewayCheckbox = document.getElementById('filterGateway');
      const internetCheckbox = document.getElementById('filterInternet');

      if (gatewayCheckbox && filterGateway !== null) {
        gatewayCheckbox.checked = filterGateway === '1';
      }

      if (internetCheckbox && filterInternet !== null) {
        internetCheckbox.checked = filterInternet === '1';
      }

      // Restore endpoint limit from localStorage
      const savedLimit = localStorage.getItem('endpointLimit') || '20';
      const limitSlider = document.getElementById('endpointLimitSlider');
      const limitValue = document.getElementById('endpointLimitValue');

      if (limitSlider && limitValue) {
        limitSlider.value = savedLimit;
        limitValue.textContent = savedLimit;
      }

      // Apply filters on page load (skip URL update to avoid redundant history)
      if (typeof cy !== 'undefined') {
        applyFilters(true);
      }

      // Apply endpoint limit on page load
      applyEndpointLimit();
    });

    // Update visible protocols in the overlay
    function updateVisibleProtocols() {
      // Get all visible protocols from visible edges
      const visibleProtocols = new Set();
      cy.edges().forEach(edge => {
        if (edge.style('display') === 'element') {
          const protocols = edge.data('protocol');
          if (protocols) {
            // Split comma-separated protocols and add each one
            protocols.split(',').forEach(proto => {
              if (proto) {
                visibleProtocols.add(proto);
              }
            });
          }
        }
      });

      // Sort protocols alphabetically
      const sortedProtocols = Array.from(visibleProtocols).sort();

      // Get the container
      const container = document.getElementById('protocols-container');

      // Clear existing badges
      container.innerHTML = '';

      // Create badges for all visible protocols
      if (sortedProtocols.length === 0) {
        container.innerHTML = '<div class="empty-state">No protocols</div>';
      } else {
        sortedProtocols.forEach(protocol => {
          const badge = document.createElement('div');
          badge.className = 'protocol-badge';
          badge.dataset.protocol = protocol;
          badge.textContent = protocol;
          badge.onclick = function() { filterByProtocol(protocol, this); };

          // Preserve selected/dimmed state if there's an active filter
          if (selectedProtocol) {
            if (protocol === selectedProtocol) {
              badge.classList.add('selected');
            } else {
              badge.classList.add('dimmed');
            }
          }

          container.appendChild(badge);
        });
      }
    }

    // Check if an IP is on the local network (private IP ranges)
    function isLocalIP(ip) {
      if (!ip) return false;

      // IPv4 private ranges
      const ipv4Private = [
        /^10\./,                    // 10.0.0.0/8
        /^172\.(1[6-9]|2[0-9]|3[01])\./, // 172.16.0.0/12
        /^192\.168\./,              // 192.168.0.0/16
        /^127\./,                   // 127.0.0.0/8 (loopback)
        /^169\.254\./,              // 169.254.0.0/16 (link-local)
        /^0\.0\.0\.0/,              // Unspecified
        /^255\.255\.255\.255/       // Broadcast
      ];

      // IPv6 private/local ranges
      const ipv6Private = [
        /^::1$/,                    // Loopback
        /^fe80:/i,                  // Link-local
        /^fc00:/i,                  // Unique local address
        /^fd00:/i,                  // Unique local address
        /^::$/                      // Unspecified
      ];

      for (let pattern of ipv4Private) {
        if (pattern.test(ip)) return true;
      }

      for (let pattern of ipv6Private) {
        if (pattern.test(ip)) return true;
      }

      return false;
    }

    // Filter nodes by type
    function applyFilters(skipUrlUpdate = false) {
      // Get type filter states
      const showGateway = document.getElementById('filterGateway').checked;
      const showInternet = document.getElementById('filterInternet').checked;

      // Save filter state to URL
      if (!skipUrlUpdate) {
        const url = new URL(window.location.href);
        url.searchParams.set('filter_gateway', showGateway ? '1' : '0');
        url.searchParams.set('filter_internet', showInternet ? '1' : '0');
        window.history.replaceState({}, '', url);
      }

      // Filter nodes in graph
      cy.nodes().forEach(node => {
        const type = node.data('type');

        // Check type filter
        let typeMatch = true;
        if (type === 'gateway' && !showGateway) typeMatch = false;
        else if (type === 'internet' && !showInternet) typeMatch = false;

        // Apply filter
        if (typeMatch) {
          node.style('display', 'element');
        } else {
          node.style('display', 'none');
        }
      });

      // Hide edges connected to hidden nodes
      cy.edges().forEach(edge => {
        const sourceVisible = edge.source().style('display') === 'element';
        const targetVisible = edge.target().style('display') === 'element';
        edge.style('display', sourceVisible && targetVisible ? 'element' : 'none');
      });

      // Filter endpoints in sidebar list (reapply search filter to respect type filters)
      const searchInput = document.getElementById('endpointSearchInput');
      if (searchInput) {
        filterEndpointsList(searchInput.value);
      }

      // Filter IPs and hostnames in endpoint details based on internet filter
      if (!showInternet) {
        // Hide internet-facing IPs
        const ipItems = document.querySelectorAll('#ips-container .hostname-item');
        ipItems.forEach(item => {
          const ip = item.textContent.trim();
          if (!isLocalIP(ip)) {
            item.style.display = 'none';
          } else {
            item.style.display = 'block';
          }
        });

        // Note: Hostnames are harder to classify without backend help,
        // so we'll keep them visible for now unless you want to filter more aggressively
      } else {
        // Show all IPs when internet filter is enabled
        const ipItems = document.querySelectorAll('#ips-container .hostname-item');
        ipItems.forEach(item => {
          item.style.display = 'block';
        });
      }

      // Update visible protocols in overlay
      updateVisibleProtocols();
    }

    // Filter hostnames list in right pane
    function filterHostnamesList(searchTerm) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const hostnameItems = document.querySelectorAll('#hostnames-container .hostname-item');

      hostnameItems.forEach(item => {
        const hostname = item.textContent.toLowerCase();
        if (normalizedSearch === '' || hostname.includes(normalizedSearch)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    }

    // Filter IPs list in right pane
    function filterIpsList(searchTerm) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const ipItems = document.querySelectorAll('#ips-container .hostname-item');

      ipItems.forEach(item => {
        const ip = item.textContent.toLowerCase();
        if (normalizedSearch === '' || ip.includes(normalizedSearch)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    }

    // Filter MACs list in right pane
    function filterMacsList(searchTerm) {
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const macItems = document.querySelectorAll('#macs-container .hostname-item');

      macItems.forEach(item => {
        const mac = item.textContent.toLowerCase();
        if (normalizedSearch === '' || mac.includes(normalizedSearch)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    }

    // Global variable to track selected protocol
    let selectedProtocol = null;

    // Filter graph by protocol
    function filterByProtocol(protocol, element) {
      selectedProtocol = protocol;

      // Find all nodes that communicate with this protocol
      const relevantNodeIds = new Set();
      cy.edges().forEach(edge => {
        const edgeProtocols = edge.data('protocol').split(',');
        if (edgeProtocols.includes(protocol)) {
          relevantNodeIds.add(edge.source().id());
          relevantNodeIds.add(edge.target().id());
        }
      });

      // Show/hide nodes based on protocol
      cy.nodes().forEach(node => {
        if (relevantNodeIds.has(node.id())) {
          node.style('display', 'element');
        } else {
          node.style('display', 'none');
        }
      });

      // Show/hide edges based on protocol
      cy.edges().forEach(edge => {
        const edgeProtocols = edge.data('protocol').split(',');
        if (edgeProtocols.includes(protocol)) {
          edge.style('display', 'element');
          edge.style('opacity', 0.8);
          edge.style('width', 2);
        } else {
          edge.style('display', 'none');
        }
      });

      // Update UI - highlight selected protocol badge, dim others
      document.querySelectorAll('.protocol-badge').forEach(badge => {
        if (badge.dataset.protocol === protocol) {
          badge.classList.add('selected');
          badge.classList.remove('dimmed');
        } else {
          badge.classList.remove('selected');
          badge.classList.add('dimmed');
        }
      });

      // Show clear filter button
      document.querySelector('.clear-filter-btn').style.display = 'block';
    }

    // Clear protocol filter
    function clearProtocolFilter() {
      selectedProtocol = null;

      // Reset all nodes and edges to visible
      cy.nodes().forEach(node => {
        node.style('display', 'element');
      });

      cy.edges().forEach(edge => {
        edge.style('display', 'element');
        edge.style('opacity', 0.4);
        edge.style('width', 1.5);
      });

      // Reset protocol badges first
      document.querySelectorAll('.protocol-badge').forEach(badge => {
        badge.classList.remove('selected');
        badge.classList.remove('dimmed');
      });

      // Re-apply type filters (this will also update visible protocols)
      applyFilters();

      // Hide clear filter button
      document.querySelector('.clear-filter-btn').style.display = 'none';
    }

    // Copy to clipboard with visual feedback
    function copyToClipboard(text, element) {
      navigator.clipboard.writeText(text).then(() => {
        const originalBg = element.style.background;
        element.style.background = 'var(--accent-success)';
        element.style.color = 'white';
        setTimeout(() => {
          element.style.background = originalBg;
          element.style.color = '';
        }, 500);
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }

    // Initialize Cytoscape graph
    var cy = cytoscape({
      container: document.getElementById('cy'),
      boxSelectionEnabled: false,
      autounselectify: true,
      layout: {
        name: 'cose',
        nodeRepulsion: 400000,
        nodeDimensionsIncludeLabels: true,
        padding: 80,
        animate: true,
        animationDuration: 500
      },
      elements: [
        {% for endpoint in endpoints %}
          { data: {
              id: '{{ endpoint | safe }}',
              {% if endpoint == hostname %}type: 'local',
              {% else %}type: '{{ endpoint_types[endpoint] }}',
              {% endif %}
              {% if endpoint == selected_node %}selected: true,{% endif %}
            }
          },
        {% endfor %}
        {% for comm in communications %}
          {% if comm.src_hostname != comm.dst_hostname %}
          { data: {
            id: '{{ comm.sub_protocol | safe }}-{{ comm.src_hostname | safe }}-{{ comm.dst_hostname | safe }}',
            source: '{{ comm.src_hostname | safe }}',
            target: '{{ comm.dst_hostname | safe }}',
            label: '{{ comm.sub_protocol | safe }}',
            protocol: '{{ comm.sub_protocol | safe }}'
          }},
          {% endif %}
        {% endfor %}
      ],
      style: [
        {
          selector: 'node',
          style: {
            'label': function(ele) { return 'üíª\n' + ele.data('id'); },
            'shape': 'round-rectangle',
            'background-color': '#1e293b',
            'font-size': 11,
            'font-weight': 600,
            'text-valign': 'center',
            'text-halign': 'center',
            'text-wrap': 'wrap',
            'text-max-width': '120px',
            'text-outline-width': 2,
            'text-outline-color': '#0f172a',
            'color': '#f1f5f9',
            'width': 60,
            'height': 60,
            'border-width': 2,
            'border-color': '#64748b'
          }
        },
        {
          selector: 'node[type = "local"]',
          style: {
            'label': function(ele) { return 'üñ•Ô∏è\n' + ele.data('id'); },
            'background-color': '#2d1b4e',
            'border-color': '#8b5cf6',
            'border-width': 3
          }
        },
        {
          selector: 'node[type = "gateway"]',
          style: {
            'label': function(ele) { return 'üåê\n' + ele.data('id'); },
            'background-color': '#422006',
            'border-color': '#f59e0b',
            'border-width': 3
          }
        },
        {
          selector: 'node[type = "internet"]',
          style: {
            'label': function(ele) { return 'üåç\n' + ele.data('id'); },
            'background-color': '#083344',
            'border-color': '#06b6d4',
            'border-width': 2
          }
        },
        {
          selector: 'node[selected = "true"]',
          style: {
            'border-width': 4,
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "local"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "gateway"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'node[type = "internet"][selected = "true"]',
          style: {
            'border-color': '#10b981'
          }
        },
        {
          selector: 'edge',
          style: {
            'target-arrow-shape': 'triangle',
            'label': 'data(label)',
            'curve-style': 'bezier',
            'width': 1.5,
            'opacity': 0.4,
            'line-color': '#475569',
            'target-arrow-color': '#475569',
            'font-size': 0,
            'color': '#94a3b8',
            'text-outline-width': 2,
            'text-outline-color': '#0f172a'
          }
        },
        {
          selector: 'edge:selected',
          style: {
            'font-size': 9,
            'opacity': 0.8,
            'width': 2
          }
        }
      ],
    });

    // Initialize visible protocols on page load
    updateVisibleProtocols();

    // Node click handler
    cy.on('tap', 'node', function(event) {
      var nodeId = event.target.id();
      var currentUrl = new URL(window.location.href);
      var currentNodeParam = currentUrl.searchParams.get('node');

      if (currentNodeParam !== nodeId) {
        currentUrl.searchParams.set('node', nodeId);
        window.location.href = currentUrl.toString();
      }
    });

    // Auto-refresh management
    let refreshIntervalId = null;

    function updateRefreshInterval(seconds) {
      // Save preference
      localStorage.setItem('refreshInterval', seconds);

      // Clear existing interval
      if (refreshIntervalId) {
        clearInterval(refreshIntervalId);
        refreshIntervalId = null;
      }

      // Update pulse indicator
      const pulse = document.querySelector('.pulse');

      if (seconds == 0) {
        pulse.style.display = 'none';
      } else {
        pulse.style.display = 'block';

        // Set new interval
        refreshIntervalId = setInterval(() => {
          window.location.reload();
        }, seconds * 1000);
      }
    }

    // Initialize refresh interval on page load
    window.addEventListener('DOMContentLoaded', () => {
      const savedInterval = localStorage.getItem('refreshInterval') || '5';
      document.getElementById('refreshInterval').value = savedInterval;
      updateRefreshInterval(savedInterval);
    });
  </script>
</body>
</html>
