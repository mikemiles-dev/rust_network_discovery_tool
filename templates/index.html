<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Awareness - Network Discovery</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --accent-primary: #3b82f6;
      --accent-secondary: #8b5cf6;
      --accent-success: #10b981;
      --border-color: #334155;
      --shadow: rgba(0, 0, 0, 0.3);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow: hidden;
    }

    /* Header */
    header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 8px var(--shadow);
      z-index: 100;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .controls {
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .control-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    select {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 150px;
    }

    select:hover {
      border-color: var(--accent-primary);
      background: var(--bg-secondary);
    }

    select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Main Layout */
    .container {
      display: flex;
      height: calc(100vh - 73px);
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .card {
      background: var(--bg-tertiary);
      border-radius: 0.5rem;
      padding: 0.875rem;
      border: 1px solid var(--border-color);
    }

    .card-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
    }

    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    input[type="text"] {
      flex: 1;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    button {
      background: var(--accent-primary);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    button:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
    }

    button.secondary:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-primary);
      box-shadow: none;
    }

    .list-box {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      max-height: 100px;
      overflow-y: auto;
      margin-bottom: 0.375rem;
    }

    .list-item {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid var(--border-color);
      font-family: 'Monaco', 'Courier New', monospace;
    }

    .list-item:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .list-item:active {
      transform: translateY(0);
    }

    .section {
      margin-bottom: 0.75rem;
    }

    .section:last-child {
      margin-bottom: 0;
    }

    /* Graph Container */
    #graph-container {
      flex: 1;
      position: relative;
      background: var(--bg-primary);
    }

    #cy {
      width: 100%;
      height: 100%;
      padding-right: 320px;
    }

    /* Stats Badge */
    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.375rem;
      margin-top: 0.5rem;
    }

    .stat-badge {
      background: var(--bg-primary);
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.6875rem;
      color: var(--text-secondary);
    }

    .stat-number {
      color: var(--accent-primary);
      font-weight: 600;
    }

    /* Auto-refresh indicator */
    .refresh-indicator {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      z-index: 50;
    }

    .pulse {
      width: 8px;
      height: 8px;
      background: var(--accent-success);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--border-color);
    }

    /* Empty state */
    .empty-state {
      color: var(--text-secondary);
      font-size: 0.75rem;
      font-style: italic;
      padding: 0.375rem 0.5rem;
    }

    /* Protocols Overlay */
    .protocols-overlay {
      position: absolute;
      top: 1rem;
      right: 1rem;
      max-width: 380px;
      max-height: calc(100vh - 120px);
      background: rgba(30, 41, 59, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(51, 65, 85, 0.6);
      border-radius: 0.75rem;
      padding: 1rem;
      z-index: 10;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .overlay-header {
      font-size: 0.875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(51, 65, 85, 0.6);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .clear-filter-btn {
      background: var(--accent-secondary);
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.625rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .clear-filter-btn:hover {
      background: #7c3aed;
      transform: translateY(-1px);
    }

    .overlay-content {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .protocol-badge {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid var(--border-color);
      white-space: nowrap;
    }

    .protocol-badge:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .protocol-badge:active {
      transform: translateY(0);
    }

    .protocol-badge.selected {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }

    .protocol-badge.dimmed {
      opacity: 0.4;
    }

    .overlay-hostnames {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      overflow-y: auto;
      max-height: 250px;
    }

    .hostname-item {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid var(--border-color);
      font-family: 'Monaco', 'Courier New', monospace;
    }

    .hostname-item:hover {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .hostname-item:active {
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">‚ö° Awareness</div>
    <div class="controls">
      <div class="control-group">
        <label class="control-label">Endpoint</label>
        <select id="nodeSelector" onchange="selectNode(this.value)" autofocus>
          {% for node in dropdown_endpoints %}
          <option value="{{ node }}" {% if node == selected_node %}selected{% endif %}>{{ node }}</option>
          {% endfor %}
        </select>
      </div>
      <div class="control-group">
        <label class="control-label">Time Range</label>
        <select id="scanInterval" onchange="selectScanInterval(this.value)">
          <option value="5" {% if scan_interval == 5 %}selected{% endif %}>5 Minutes</option>
          <option value="15" {% if scan_interval == 15 %}selected{% endif %}>15 Minutes</option>
          <option value="30" {% if scan_interval == 30 %}selected{% endif %}>30 Minutes</option>
          <option value="60" {% if scan_interval == 60 %}selected{% endif %}>1 Hour</option>
          <option value="240" {% if scan_interval == 240 %}selected{% endif %}>4 Hours</option>
          <option value="1440" {% if scan_interval == 1440 %}selected{% endif %}>1 Day</option>
        </select>
      </div>
      <div class="control-group">
        <label class="control-label">Auto-Refresh</label>
        <select id="refreshInterval" onchange="updateRefreshInterval(this.value)">
          <option value="0">Off</option>
          <option value="3">3 seconds</option>
          <option value="5" selected>5 seconds</option>
          <option value="10">10 seconds</option>
          <option value="30">30 seconds</option>
          <option value="60">1 minute</option>
        </select>
      </div>
      <div class="control-group">
        <label class="control-label">Filter</label>
        <div style="display: flex; gap: 0.75rem; align-items: center;">
          <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.875rem; cursor: pointer;">
            <input type="checkbox" id="filterLocal" checked onchange="applyFilters()" style="cursor: pointer;">
            <span>üñ•Ô∏è Local</span>
          </label>
          <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.875rem; cursor: pointer;">
            <input type="checkbox" id="filterGateway" checked onchange="applyFilters()" style="cursor: pointer;">
            <span>üåê Gateway</span>
          </label>
          <label style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.875rem; cursor: pointer;">
            <input type="checkbox" id="filterInternet" checked onchange="applyFilters()" style="cursor: pointer;">
            <span>üåç Internet</span>
          </label>
        </div>
      </div>
    </div>
  </header>

  <div class="container">
    <aside class="sidebar">
      <div class="card">
        <div class="card-title">Endpoint Details</div>
        <div class="input-group">
          <input name="endpoint_name" type="text" value="{{ endpoint }}" placeholder="Endpoint name">
          <button onclick="updateEndpointName()">Update</button>
        </div>
        <div class="stats">
          <div class="stat-badge">IPs: <span class="stat-number">{{ ips|length }}</span></div>
          <div class="stat-badge">MACs: <span class="stat-number">{{ macs|length }}</span></div>
          <div class="stat-badge">Hosts: <span class="stat-number">{{ hostnames|length }}</span></div>
          <div class="stat-badge">Protocols: <span class="stat-number">{{ protocols|length }}</span></div>
        </div>
        <div class="stats" style="margin-top: 0.5rem;">
          <div class="stat-badge">‚¨áÔ∏è In: <span class="stat-number" id="bytes-in">{{ bytes_in }}</span></div>
          <div class="stat-badge">‚¨ÜÔ∏è Out: <span class="stat-number" id="bytes-out">{{ bytes_out }}</span></div>
        </div>
      </div>

      <div class="card">
        <!-- IP Addresses -->
        <div class="section">
          <div class="card-title">IP Addresses</div>
          <div class="list-box" id="ips-container">
            {% if ips %}
              {% for ip in ips %}
              <div class="list-item" onclick="copyToClipboard('{{ ip }}', this)">{{ ip }}</div>
              {% endfor %}
            {% else %}
              <div class="empty-state">No IP addresses</div>
            {% endif %}
          </div>
        </div>

        <!-- MAC Addresses -->
        <div class="section">
          <div class="card-title">MAC Addresses</div>
          <div class="list-box" id="macs-container">
            {% if macs %}
              {% for mac in macs %}
              <div class="list-item" onclick="copyToClipboard('{{ mac }}', this)">{{ mac }}</div>
              {% endfor %}
            {% else %}
              <div class="empty-state">No MAC addresses</div>
            {% endif %}
          </div>
        </div>

      </div>
    </aside>

    <main id="graph-container">
      <div id="cy"></div>

      <!-- Protocols Overlay -->
      <div class="protocols-overlay">
        <div class="overlay-header">
          Protocols
          <button class="clear-filter-btn" onclick="clearProtocolFilter()" style="display: none;">Clear Filter</button>
        </div>
        <div class="overlay-content" id="protocols-container">
          <!-- Protocols will be dynamically generated from graph data -->
        </div>

        <div class="overlay-header" style="margin-top: 0.5rem;">
          Hostnames
        </div>
        <div class="overlay-hostnames" id="hostnames-container">
          {% if hostnames %}
            {% for hostname in hostnames %}
            <div class="hostname-item" onclick="copyToClipboard('{{ hostname }}', this)">{{ hostname }}</div>
            {% endfor %}
          {% else %}
            <div class="empty-state">No hostnames</div>
          {% endif %}
        </div>
      </div>
    </main>
  </div>

  <div class="refresh-indicator">
    <div class="pulse"></div>
    <span>Live monitoring</span>
  </div>

  <script>
    // Navigation functions
    function selectNode(nodeId) {
      const url = new URL(window.location.href);
      url.searchParams.set('node', nodeId);
      window.location.href = url.toString();
    }

    function selectScanInterval(interval) {
      const url = new URL(window.location.href);
      url.searchParams.set('scan_interval', interval);
      window.location.href = url.toString();
    }

    // Format bytes to human-readable format
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Format byte displays on page load
    document.addEventListener('DOMContentLoaded', function() {
      const bytesInElem = document.getElementById('bytes-in');
      const bytesOutElem = document.getElementById('bytes-out');

      if (bytesInElem) {
        const bytesIn = parseInt(bytesInElem.textContent);
        bytesInElem.textContent = formatBytes(bytesIn);
      }

      if (bytesOutElem) {
        const bytesOut = parseInt(bytesOutElem.textContent);
        bytesOutElem.textContent = formatBytes(bytesOut);
      }
    });

    // Update visible protocols in the overlay
    function updateVisibleProtocols() {
      // Get all visible protocols from visible edges
      const visibleProtocols = new Set();
      cy.edges().forEach(edge => {
        if (edge.style('display') === 'element') {
          const protocols = edge.data('protocol');
          if (protocols) {
            // Split comma-separated protocols and add each one
            protocols.split(',').forEach(proto => {
              if (proto) {
                visibleProtocols.add(proto);
              }
            });
          }
        }
      });

      // Sort protocols alphabetically
      const sortedProtocols = Array.from(visibleProtocols).sort();

      // Get the container
      const container = document.getElementById('protocols-container');

      // Clear existing badges
      container.innerHTML = '';

      // Create badges for all visible protocols
      if (sortedProtocols.length === 0) {
        container.innerHTML = '<div class="empty-state">No protocols</div>';
      } else {
        sortedProtocols.forEach(protocol => {
          const badge = document.createElement('div');
          badge.className = 'protocol-badge';
          badge.dataset.protocol = protocol;
          badge.textContent = protocol;
          badge.onclick = function() { filterByProtocol(protocol, this); };

          // Preserve selected/dimmed state if there's an active filter
          if (selectedProtocol) {
            if (protocol === selectedProtocol) {
              badge.classList.add('selected');
            } else {
              badge.classList.add('dimmed');
            }
          }

          container.appendChild(badge);
        });
      }
    }

    // Filter nodes by type
    function applyFilters() {
      const showLocal = document.getElementById('filterLocal').checked;
      const showGateway = document.getElementById('filterGateway').checked;
      const showInternet = document.getElementById('filterInternet').checked;

      cy.nodes().forEach(node => {
        const type = node.data('type');
        let shouldShow = true;

        if (type === 'local' && !showLocal) {
          shouldShow = false;
        } else if (type === 'gateway' && !showGateway) {
          shouldShow = false;
        } else if (type === 'internet' && !showInternet) {
          shouldShow = false;
        }

        if (shouldShow) {
          node.style('display', 'element');
        } else {
          node.style('display', 'none');
        }
      });

      // Hide edges connected to hidden nodes
      cy.edges().forEach(edge => {
        const source = edge.source();
        const target = edge.target();
        const sourceVisible = source.style('display') === 'element';
        const targetVisible = target.style('display') === 'element';

        if (sourceVisible && targetVisible) {
          edge.style('display', 'element');
        } else {
          edge.style('display', 'none');
        }
      });

      // Update visible protocols after filtering
      updateVisibleProtocols();
    }

    // Global variable to track selected protocol
    let selectedProtocol = null;

    // Filter graph by protocol
    function filterByProtocol(protocol, element) {
      selectedProtocol = protocol;

      // Find all nodes that communicate with this protocol
      const relevantNodeIds = new Set();
      cy.edges().forEach(edge => {
        const edgeProtocols = edge.data('protocol').split(',');
        if (edgeProtocols.includes(protocol)) {
          relevantNodeIds.add(edge.source().id());
          relevantNodeIds.add(edge.target().id());
        }
      });

      // Show/hide nodes based on protocol
      cy.nodes().forEach(node => {
        if (relevantNodeIds.has(node.id())) {
          node.style('display', 'element');
        } else {
          node.style('display', 'none');
        }
      });

      // Show/hide edges based on protocol
      cy.edges().forEach(edge => {
        const edgeProtocols = edge.data('protocol').split(',');
        if (edgeProtocols.includes(protocol)) {
          edge.style('display', 'element');
          edge.style('opacity', 0.8);
          edge.style('width', 2);
        } else {
          edge.style('display', 'none');
        }
      });

      // Update UI - highlight selected protocol badge, dim others
      document.querySelectorAll('.protocol-badge').forEach(badge => {
        if (badge.dataset.protocol === protocol) {
          badge.classList.add('selected');
          badge.classList.remove('dimmed');
        } else {
          badge.classList.remove('selected');
          badge.classList.add('dimmed');
        }
      });

      // Show clear filter button
      document.querySelector('.clear-filter-btn').style.display = 'block';
    }

    // Clear protocol filter
    function clearProtocolFilter() {
      selectedProtocol = null;

      // Reset all nodes and edges to visible
      cy.nodes().forEach(node => {
        node.style('display', 'element');
      });

      cy.edges().forEach(edge => {
        edge.style('display', 'element');
        edge.style('opacity', 0.4);
        edge.style('width', 1.5);
      });

      // Reset protocol badges first
      document.querySelectorAll('.protocol-badge').forEach(badge => {
        badge.classList.remove('selected');
        badge.classList.remove('dimmed');
      });

      // Re-apply type filters (this will also update visible protocols)
      applyFilters();

      // Hide clear filter button
      document.querySelector('.clear-filter-btn').style.display = 'none';
    }

    // Copy to clipboard with visual feedback
    function copyToClipboard(text, element) {
      navigator.clipboard.writeText(text).then(() => {
        const originalBg = element.style.background;
        element.style.background = 'var(--accent-success)';
        element.style.color = 'white';
        setTimeout(() => {
          element.style.background = originalBg;
          element.style.color = '';
        }, 500);
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }

    // Update endpoint name
    function updateEndpointName() {
      const endpointNameInput = document.querySelector('input[name="endpoint_name"]');
      const newHostname = endpointNameInput.value.trim();
      const currentHostname = "{{ endpoint }}";

      // Validate input
      if (!newHostname) {
        alert('Please enter a valid endpoint name.');
        return;
      }

      if (newHostname === currentHostname) {
        alert('New name is the same as the current name.');
        return;
      }

      // Disable button during update
      const updateButton = event.target;
      updateButton.disabled = true;
      updateButton.textContent = 'Updating...';

      fetch(`/update_endpoint?hostname=${encodeURIComponent(currentHostname)}&new_hostname=${encodeURIComponent(newHostname)}`, {
        method: 'GET',
      })
      .then(response => {
        if (response.ok) {
          // Success - redirect to the updated endpoint
          const url = new URL(window.location.href);
          url.searchParams.set('node', newHostname);
          window.location.href = url.toString();
        } else {
          // Handle errors
          return response.text().then(errorMsg => {
            console.error('Update failed:', errorMsg);
            alert(`Failed to update endpoint name: ${errorMsg}`);
            updateButton.disabled = false;
            updateButton.textContent = 'Update';
          });
        }
      })
      .catch(error => {
        console.error('Error updating endpoint name:', error);
        alert('An error occurred while updating the endpoint name.');
        updateButton.disabled = false;
        updateButton.textContent = 'Update';
      });
    }

    // Initialize Cytoscape graph
    var cy = cytoscape({
      container: document.getElementById('cy'),
      boxSelectionEnabled: false,
      autounselectify: true,
      layout: {
        name: 'cose',
        nodeRepulsion: 400000,
        nodeDimensionsIncludeLabels: true,
        padding: 80,
        animate: true,
        animationDuration: 500
      },
      elements: [
        {% for endpoint in endpoints %}
          { data: {
              id: '{{ endpoint }}',
              {% if endpoint == hostname %}type: 'local',
              {% elif endpoint == selected_node %}type: 'selected',
              {% elif endpoint_types[endpoint] %}type: '{{ endpoint_types[endpoint] }}',
              {% endif %}
            }
          },
        {% endfor %}
        {% for comm in communications %}
          { data: {
            id: '{{ comm.sub_protocol }}-{{ comm.src_hostname }}-{{ comm.dst_hostname }}',
            source: '{{ comm.src_hostname }}',
            target: '{{ comm.dst_hostname }}',
            label: '{{ comm.sub_protocol }}',
            protocol: '{{ comm.sub_protocol }}'
          }},
        {% endfor %}
      ],
      style: [
        {
          selector: 'node',
          style: {
            'label': function(ele) { return 'üíª\n' + ele.data('id'); },
            'shape': 'round-rectangle',
            'background-color': '#1e293b',
            'font-size': 11,
            'font-weight': 600,
            'text-valign': 'center',
            'text-halign': 'center',
            'text-wrap': 'wrap',
            'text-max-width': '120px',
            'text-outline-width': 2,
            'text-outline-color': '#0f172a',
            'color': '#f1f5f9',
            'width': 60,
            'height': 60,
            'border-width': 2,
            'border-color': '#64748b'
          }
        },
        {
          selector: 'node[type = "local"]',
          style: {
            'label': function(ele) { return 'üñ•Ô∏è\n' + ele.data('id'); },
            'background-color': '#2d1b4e',
            'border-color': '#8b5cf6',
            'border-width': 3
          }
        },
        {
          selector: 'node[type = "gateway"]',
          style: {
            'label': function(ele) { return 'üåê\n' + ele.data('id'); },
            'background-color': '#422006',
            'border-color': '#f59e0b',
            'border-width': 3
          }
        },
        {
          selector: 'node[type = "internet"]',
          style: {
            'label': function(ele) { return 'üåç\n' + ele.data('id'); },
            'background-color': '#083344',
            'border-color': '#06b6d4',
            'border-width': 2
          }
        },
        {
          selector: 'node[type = "selected"]',
          style: {
            'border-width': 4,
            'border-color': '#10b981'
          }
        },
        {
          selector: 'edge',
          style: {
            'target-arrow-shape': 'triangle',
            'label': 'data(label)',
            'curve-style': 'bezier',
            'width': 1.5,
            'opacity': 0.4,
            'line-color': '#475569',
            'target-arrow-color': '#475569',
            'font-size': 0,
            'color': '#94a3b8',
            'text-outline-width': 2,
            'text-outline-color': '#0f172a'
          }
        },
        {
          selector: 'edge:selected',
          style: {
            'font-size': 9,
            'opacity': 0.8,
            'width': 2
          }
        }
      ],
    });

    // Initialize visible protocols on page load
    updateVisibleProtocols();

    // Node click handler
    cy.on('tap', 'node', function(event) {
      var nodeId = event.target.id();
      var currentUrl = new URL(window.location.href);
      var currentNodeParam = currentUrl.searchParams.get('node');

      if (currentNodeParam !== nodeId) {
        currentUrl.searchParams.set('node', nodeId);
        window.location.href = currentUrl.toString();
      }
    });

    // Auto-refresh management
    let refreshIntervalId = null;

    function updateRefreshInterval(seconds) {
      // Save preference
      localStorage.setItem('refreshInterval', seconds);

      // Clear existing interval
      if (refreshIntervalId) {
        clearInterval(refreshIntervalId);
        refreshIntervalId = null;
      }

      // Update indicator
      const indicator = document.querySelector('.refresh-indicator span');
      const pulse = document.querySelector('.pulse');

      if (seconds == 0) {
        indicator.textContent = 'Auto-refresh disabled';
        pulse.style.display = 'none';
      } else {
        indicator.textContent = `Refreshing every ${seconds}s`;
        pulse.style.display = 'block';

        // Set new interval
        refreshIntervalId = setInterval(() => {
          window.location.reload();
        }, seconds * 1000);
      }
    }

    // Initialize refresh interval on page load
    window.addEventListener('DOMContentLoaded', () => {
      const savedInterval = localStorage.getItem('refreshInterval') || '5';
      document.getElementById('refreshInterval').value = savedInterval;
      updateRefreshInterval(savedInterval);
    });
  </script>
</body>
</html>
