use crate::schema::DeviceRules;
use std::fmt::Write;
use std::fs;
use std::path::Path;

/// Escape a string for inclusion in a Rust string literal
fn escape(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

/// Generate the device_rules_data.rs file from parsed rules
pub fn generate(rules: &DeviceRules, output: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let mut out = String::with_capacity(32 * 1024);

    writeln!(out, "// Auto-generated by device-rules-generator â€” do not edit.")?;
    writeln!(
        out,
        "// Source: tools/device-rules-generator/device_rules.toml"
    )?;
    writeln!(out)?;

    // --- Pattern arrays (contains match) ---
    for (classification, patterns) in &rules.patterns {
        let name = format!("{}_PATTERNS", classification.to_uppercase());
        write_str_array(&mut out, &name, patterns)?;
    }

    // --- Prefix arrays (starts_with match) ---
    for (classification, prefixes) in &rules.prefixes {
        let name = format!("{}_PREFIXES", classification.to_uppercase());
        write_str_array(&mut out, &name, prefixes)?;
    }

    // --- Conditional patterns ---
    // Group by classification
    let mut conditionals_by_class: std::collections::BTreeMap<String, Vec<(&str, &str)>> =
        std::collections::BTreeMap::new();
    for c in &rules.conditionals {
        conditionals_by_class
            .entry(c.classification.clone())
            .or_default()
            .push((&c.pattern, &c.exclude));
    }
    for (classification, pairs) in &conditionals_by_class {
        let name = format!("{}_CONDITIONAL", classification.to_uppercase());
        writeln!(
            out,
            "pub(crate) const {}: &[(&str, &str)] = &[",
            name
        )?;
        for (pattern, exclude) in pairs {
            writeln!(
                out,
                "    (\"{}\", \"{}\"),",
                escape(pattern),
                escape(exclude)
            )?;
        }
        writeln!(out, "];")?;
        writeln!(out)?;
    }

    // --- Vendor class arrays ---
    for (classification, vendors) in &rules.vendor_classes {
        let name = format!("{}_VENDORS", classification.to_uppercase());
        write_str_array(&mut out, &name, vendors)?;
    }

    // --- Service arrays ---
    for (classification, services) in &rules.services {
        let name = format!("{}_SERVICES", classification.to_uppercase());
        write_str_array(&mut out, &name, services)?;
    }

    // --- Standalone lists ---
    write_str_array(&mut out, "MAC_DESKTOP_SERVICES", &rules.standalone.mac_desktop_services)?;
    write_str_array(
        &mut out,
        "SOUNDBAR_MODEL_PREFIXES",
        &rules.standalone.soundbar_model_prefixes,
    )?;
    write_str_array(
        &mut out,
        "LG_APPLIANCE_PREFIXES",
        &rules.standalone.lg_appliance_prefixes,
    )?;

    // --- TV series ---
    for series in &rules.tv_series {
        let name = format!("{}_TV_SERIES", series.vendor.to_uppercase());
        writeln!(
            out,
            "pub(crate) const {}: &[(&str, &str)] = &[",
            name
        )?;
        for entry in &series.entries {
            writeln!(
                out,
                "    (\"{}\", \"{}\"),",
                escape(&entry.pattern),
                escape(&entry.name)
            )?;
        }
        writeln!(out, "];")?;
        writeln!(out)?;
    }

    // --- Hostname vendor rules ---
    writeln!(
        out,
        "pub(crate) const HOSTNAME_VENDOR_RULES: &[(&str, &str, &str)] = &["
    )?;
    for rule in &rules.hostname_vendors {
        let code = match rule.match_type.as_str() {
            "contains" => "c",
            "starts_with" => "s",
            other => {
                return Err(format!("Unknown match_type: {}", other).into());
            }
        };
        for pattern in &rule.patterns {
            writeln!(
                out,
                "    (\"{}\", \"{}\", \"{}\"),",
                code,
                escape(pattern),
                escape(&rule.vendor)
            )?;
        }
    }
    writeln!(out, "];")?;
    writeln!(out)?;

    // --- Hostname model rules ---
    writeln!(
        out,
        "pub(crate) const HOSTNAME_MODEL_RULES: &[(&str, &str, &str)] = &["
    )?;
    for rule in &rules.hostname_models {
        let code = match rule.match_type.as_str() {
            "contains" => "c",
            "starts_with" => "s",
            other => {
                return Err(format!("Unknown match_type: {}", other).into());
            }
        };
        writeln!(
            out,
            "    (\"{}\", \"{}\", \"{}\"),",
            code,
            escape(&rule.pattern),
            escape(&rule.model)
        )?;
    }
    writeln!(out, "];")?;
    writeln!(out)?;

    // --- Vendor type model rules ---
    writeln!(
        out,
        "pub(crate) const VENDOR_TYPE_MODEL_RULES: &[(&str, &str, &str, bool)] = &["
    )?;
    for rule in &rules.vendor_type_models {
        writeln!(
            out,
            "    (\"{}\", \"{}\", \"{}\", {}),",
            escape(&rule.vendor),
            escape(&rule.device_type),
            escape(&rule.label),
            rule.literal
        )?;
    }
    writeln!(out, "];")?;
    writeln!(out)?;

    // --- MAC vendor model rules ---
    writeln!(
        out,
        "pub(crate) const MAC_VENDOR_MODEL_RULES: &[(&str, &str)] = &["
    )?;
    for rule in &rules.mac_vendor_models {
        writeln!(
            out,
            "    (\"{}\", \"{}\"),",
            escape(&rule.vendor),
            escape(&rule.model)
        )?;
    }
    writeln!(out, "];")?;
    writeln!(out)?;

    fs::write(output, &out)?;
    eprintln!("Wrote {}", output.display());
    Ok(())
}

fn write_str_array(
    out: &mut String,
    name: &str,
    items: &[String],
) -> Result<(), std::fmt::Error> {
    writeln!(out, "pub(crate) const {}: &[&str] = &[", name)?;
    for item in items {
        writeln!(out, "    \"{}\",", escape(item))?;
    }
    writeln!(out, "];")?;
    writeln!(out)?;
    Ok(())
}
